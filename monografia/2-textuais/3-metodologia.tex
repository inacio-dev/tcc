\chapter{Metodologia}
\label{chap:metodologia}

Será realizado um desenvolvimento incremental e modular de um sistema completo de \gls{teleoperacao} de um veículo de Fórmula 1 com simulador (volante e pedais), sendo o veículo controlado via protocolo \gls{UDP}. A metodologia adotada é a prototipagem evolutiva, que busca o teste individual de cada componente antes da integração final. O projeto busca um objetivo semelhante ao artigo de \citeonline{shaik2025design}, conforme apresentado na fundamentação teórica.

O projeto seguirá uma arquitetura de três camadas. A primeira corresponde ao veículo teleoperado, tendo como elemento principal o Raspberry Pi 4, responsável por receber mensagens de controle via UDP e enviar mensagens de vídeo e status de sensores. A segunda camada é o cliente (PC), que receberá as mensagens do veículo, exibirá a interface de telemetria e encaminhará as mensagens de controle oriundas do simulador para o veículo. A terceira camada é o simulador baseado em ESP32, composto por volante com \gls{encoder}, pedais de acelerador e freio, e botões de troca de marcha, responsável por capturar os comandos do usuário e transmiti-los ao cliente via comunicação serial \gls{USB}. A integração de múltiplos sensores segue a abordagem de \citeonline{bobrovsky2023development}, visando um bom resultado de feedback ao usuário. A \autoref{fig:arquitetura-projeto} apresenta o diagrama da arquitetura proposta.

O desenvolvimento inicia com a modelagem, impressão e montagem do chassi do veículo teleoperado, seguido por testes de desempenho e comunicação entre o Raspberry Pi e o cliente (PC). Na sequência, ocorre a integração gradual dos sensores e atuadores do veículo teleoperado com o Raspberry Pi e os testes de comunicação do veículo completo com o PC. A etapa seguinte compreende a modelagem, impressão e montagem do simulador (volante e pedais), além dos testes de atuadores e sensores de comando via serial. Por fim, realiza-se a integração gradual do simulador com o PC e o teste completo entre o veículo teleoperado e o simulador.

\begin{figure}[!h]
	\captionsetup{width=16cm}
	\Caption{\label{fig:arquitetura-projeto} Arquitetura do sistema de teleoperação com feedback háptico}
	\UFCfig{}{
		\includegraphics[width=16cm]{figuras/Arquitetura do Projeto}
	}{
		\Fonte{elaborado pelo autor.}
	}
\end{figure}

\section{Protocolo de Comunicação UDP}
\label{sec:protocolo-udp}

O UDP é um protocolo que lida com o alto envio de mensagens, muito utilizado para envio de streams e em jogos de computador. A arquitetura atual necessita de baixa \gls{latencia}, pois uma latência muito alta irá atrapalhar o controle em tempo real do veículo teleoperado, passando por um alto delay de comandos e prejudicando a experiência do usuário. Conforme demonstrado por \citeonline{lu2023udprt} na fundamentação teórica, protocolos baseados em UDP alcançam latências significativamente inferiores ao \gls{TCP} em aplicações de tempo real, justificando o uso desse protocolo.

\subsection{Evolução das Decisões de Arquitetura de Comunicação}
\label{subsec:evolucao-decisoes-comunicacao}

A arquitetura final de comunicação do sistema foi definida após uma série de testes experimentais com diferentes tecnologias e topologias de rede. O objetivo inicial era verificar a viabilidade de controlar múltiplos veículos simultaneamente através de um servidor central que redirecionaria mensagens entre clientes e veículos. A meta de latência estabelecida foi de no máximo 10ms para comunicação em tempo real na mesma rede local.

\subsubsection{Testes com Arduino Mega e ESP8266}

A primeira configuração testada utilizou um Arduino Mega com módulo ESP8266 como controlador do veículo, comunicando-se via WiFi com um Raspberry Pi 4 (servidor) e um notebook (cliente). Os resultados demonstraram latência média de 60ms, valor considerado inadequado para controle em tempo real. A análise identificou o módulo ESP8266 como gargalo do sistema: mesmo com o Raspberry Pi enviando mensagens a cada 1ms, o ESP8266 não conseguia processar adequadamente devido à necessidade de alternar entre modos de leitura e escrita para processar e transmitir mensagens.

\subsubsection{Testes com ESP32}

Para melhorar o processamento, o Arduino Mega com ESP8266 foi substituído por um ESP32 DevKit V1, que possui processador dual-core mais potente apesar de menor quantidade de pinos \gls{GPIO}. A latência reduziu para 40ms, representando melhoria de 33\% em relação à configuração anterior. Entretanto, esse valor ainda não atendia à meta de 10ms, considerando que a comunicação UDP entre servidor e cliente adicionaria latência adicional em cenários com servidores geograficamente distribuídos.

\subsubsection{Testes com Módulo NRF24L01}

Buscando comunicação mais rápida entre servidor e veículo, foram realizados testes com módulos de rádio NRF24L01 com antena externa, capazes de alcançar até 800 metros com boa qualidade de sinal. Os resultados foram expressivos: latência de apenas 2ms entre os dispositivos. Porém, essa abordagem implica comunicação direta ponto-a-ponto entre servidor e veículo, aumentando a complexidade para adicionar novos veículos ao sistema.

\subsubsection{Avaliação de Redes Mesh}

Para estender o alcance além dos 800 metros do NRF24L01, foi avaliada a implementação de rede mesh. A análise indicou acréscimo de aproximadamente 2ms de latência para cada salto entre antenas intermediárias, além de introduzir erros na resposta de status do veículo. Uma otimização testada foi utilizar o payload de \gls{ACK} para retorno de status dos sensores. O ACK é uma confirmação de recebimento que o NRF24L01 envia automaticamente ao transmissor; ao anexar dados do sensor nessa confirmação, elimina-se a necessidade de alternar o módulo entre modos de transmissão e recepção, reduzindo latência. Contudo, essa abordagem tornou a implementação de mesh com NRF24L01 excessivamente complexa para o cronograma disponível.

O protocolo ESP-NOW foi considerado como alternativa para comunicação mesh entre dispositivos ESP32, porém foi descartado devido ao alcance limitado de aproximadamente 50 metros, significativamente inferior aos 800 metros do NRF24L01 com antena externa, além do custo mais elevado por unidade.

\subsubsection{Decisão Final: Arquitetura UDP com Raspberry Pi e ESP32}

A análise comparativa dos testes, sumarizada na \autoref{tab:comparativo-comunicacao}, conduziu à definição da arquitetura final baseada em três pilares: protocolo UDP, Raspberry Pi 4 embarcado no veículo e ESP32 no simulador. O princípio norteador foi manter o sistema simples e funcional.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:comparativo-comunicacao} Comparativo de latência entre tecnologias de comunicação testadas}
\IBGEtab{}{%
	\begin{tabular}{p{5cm}p{3cm}p{3cm}p{4cm}}
		\toprule
		Configuração & Latência Média & Alcance & Observações \\
		\midrule \midrule
		Arduino Mega + ESP8266 & 60ms & WiFi local & Gargalo no ESP8266 \\
		\midrule
		ESP32 DevKit V1 & 40ms & WiFi local & Melhoria de 33\% \\
		\midrule
		NRF24L01 + antena & 2ms & 800m & Comunicação ponto-a-ponto \\
		\midrule
		NRF24L01 mesh & 2ms + 2ms/salto & Extensível & Complexidade elevada \\
		\midrule
		ESP-NOW (ESP32) & Similar ao WiFi & 50m & Custo elevado, alcance limitado \\
		\midrule
		\textbf{RPi 4 embarcado + UDP} & \textbf{$\sim$2ms} & \textbf{WiFi local} & \textbf{Solução adotada} \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

A comunicação via rádio NRF24L01, apesar de apresentar excelente latência (2ms) e alcance (800m), exigiria a implementação de um broker intermediário para traduzir os pacotes de rádio para o protocolo UDP do servidor. Essa camada adicional aumentaria a complexidade do sistema, introduziria novos pontos de falha e demandaria desenvolvimento de firmware específico para gerenciamento da comunicação bidirecional entre rádio e rede IP. Além disso, embora o NRF24L01 seja adequado para transmissão de comandos de controle (pacotes pequenos de dezenas de bytes), a transmissão de vídeo em tempo real seria inviável: o módulo opera com taxa máxima de 2 Mbps e payload limitado a 32 bytes por pacote, tornando a fragmentação e remontagem de frames \gls{MJPEG} (10 a 50 KB cada) excessivamente complexa e propensa a erros. Implementar um protocolo confiável de transmissão de imagem sobre rádio demandaria esforço de desenvolvimento incompatível com o cronograma do projeto.

A decisão de embarcar o Raspberry Pi 4 diretamente no veículo eliminou essas limitações, permitindo comunicação UDP nativa sobre WiFi. Com o Raspberry Pi embarcado, a captura de vídeo, codificação MJPEG e transmissão UDP ocorrem internamente no mesmo dispositivo, simplificando drasticamente a arquitetura. O Raspberry Pi atua simultaneamente como controlador do veículo e servidor UDP, processando vídeo da câmera OV5647, dados do sensor BMI160 e comandos de controle em uma única plataforma. Para simplificar a descoberta de dispositivos na rede local, foi adotado o protocolo mDNS, permitindo que o veículo seja acessado pelo nome \texttt{f1car.local} e o cliente por \texttt{f1client.local}, eliminando a necessidade de configuração manual de endereços IP.

A arquitetura de comunicação utiliza três portas UDP separadas para otimizar o desempenho de cada tipo de dado, conforme detalhado na \autoref{tab:arquitetura-portas-udp}. Essa separação é necessária porque pacotes de vídeo grandes (50 KB) bloqueariam os pacotes pequenos de sensores (200 bytes) se compartilhassem a mesma porta, e o sistema de \gls{forcefeedback} requer taxa consistente de 100Hz com latência inferior a 10ms para resposta tátil adequada no volante.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:arquitetura-portas-udp} Arquitetura de comunicação UDP com três portas separadas}
\IBGEtab{}{%
	\begin{tabular}{ccp{5cm}ccc}
		\toprule
		Porta & Direção & Conteúdo & Taxa & Pacote & Buffer \\
		\midrule \midrule
		9999 & RPi $\rightarrow$ PC & Vídeo MJPEG + energia + temperatura & 30Hz & 10--50 KB & 64 KB \\
		\midrule
		9997 & RPi $\rightarrow$ PC & Sensores BMI160 (aceleração e giroscópio) & 100Hz & 200 B & 8 KB \\
		\midrule
		9998 & Bidirecional & Comandos de controle (acelerador, freio, direção, marcha) & On-demand & 50 B & 8 KB \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

Para o simulador, o ESP32 DevKit V1 foi mantido devido ao seu processamento superior em relação ao Arduino Mega, com dual-core de 240MHz contra single-core de 16MHz. O firmware opera com taxa de atualização de 100Hz (intervalo de 10ms entre transmissões), permitindo leitura simultânea de três encoders rotacionais, processamento de comandos de force feedback e comunicação serial USB a 115200 baud com o cliente PC sem perda de dados. O processamento é distribuído entre os dois núcleos: o Core 0 executa a leitura de encoders e controle do motor de force feedback com alta prioridade, enquanto o Core 1 gerencia a comunicação serial. A comunicação serial USB entre ESP32 e cliente elimina a necessidade de protocolos wireless adicionais no simulador, garantindo conexão estável e determinística.

Essa arquitetura resultou em um sistema com apenas dois saltos de comunicação (Veículo $\leftrightarrow$ Cliente $\leftrightarrow$ Simulador), maximizando a confiabilidade e minimizando a latência total do loop de controle.

\subsection{Justificativa para UDP Simples}
\label{subsec:justificativa-udp}

A escolha do UDP simples sobre protocolos mais avançados como UDP-RT \citeonline{lu2023udprt} é justificada pela necessidade de simplicidade de implementação e recursos limitados do Raspberry Pi 4. Embora o UDP-RT ofereça vantagens em redes congestionadas, sua implementação requer mecanismos adicionais de correção de erros e detecção na camada de aplicação, aumentando significativamente a complexidade do sistema. Conforme demonstrado nos resultados, a latência obtida de 1,94ms com UDP simples supera os targets típicos de 5ms, validando que esta abordagem é adequada para o projeto.

\subsection{Limitações de Alcance e Considerações de Escala}
\label{subsec:limitacoes-alcance}

O alcance da comunicação WiFi constitui uma limitação relevante para operação do veículo em pistas de maior extensão. Considerando que o veículo foi construído na escala 1:5 e que circuitos de Fórmula 1 reais possuem extensões entre 3 km (Mônaco) e 7 km (Spa-Francorchamps), uma pista em escala correspondente teria entre 600 m e 1.400 m de comprimento.

A \autoref{tab:alcance-wifi-pistas} apresenta a análise de viabilidade de cobertura WiFi para pistas em escala 1:5, considerando as características de roteadores comerciais e possíveis extensões de alcance.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:alcance-wifi-pistas} Análise de cobertura WiFi para pistas de F1 em escala 1:5}
\IBGEtab{}{%
	\begin{tabular}{p{4cm}p{2.5cm}p{2.5cm}p{5.5cm}}
		\toprule
		Circuito Real & Extensão Real & Escala 1:5 & Solução de Cobertura \\
		\midrule \midrule
		Mônaco & 3,337 km & 667 m & Roteador central + 1 repetidor \\
		\midrule
		Interlagos & 4,309 km & 862 m & 2 access points mesh \\
		\midrule
		Silverstone & 5,891 km & 1.178 m & 3 access points mesh \\
		\midrule
		Spa-Francorchamps & 7,004 km & 1.401 m & 4 access points mesh ou 5G \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

Para pistas de até 600 m (equivalente a circuitos compactos como Mônaco), um roteador WiFi comercial de alta potência (20 dBm) posicionado centralmente oferece cobertura adequada em ambiente aberto. Para pistas maiores, a implementação de redes mesh com múltiplos access points permite extensão do alcance, adicionando aproximadamente 2 ms de latência por salto entre nós da rede. Alternativamente, redes 5G oferecem cobertura ampla com latência potencialmente inferior, porém com maior custo de infraestrutura e dependência de operadoras.

O projeto atual foi validado em ambiente de teste com dimensões de 5 m $\times$ 8 m, suficiente para testes controlados em ambiente interno. A extensão para pistas maiores requer planejamento de infraestrutura de rede conforme as dimensões do circuito desejado.

% ============================================================================
% ARQUITETURA DO VEÍCULO (RASPBERRY PI 4)
% ============================================================================
\section{Arquitetura do Veículo (Raspberry Pi 4)}
\label{sec:arquitetura-veiculo}

O Raspberry Pi 4 Model B com 8GB de \gls{RAM} constitui o núcleo de processamento embarcado no veículo, responsável por todas as operações de controle, sensoriamento e comunicação. A escolha deste hardware foi motivada pela capacidade de processamento suficiente para codificação de vídeo MJPEG em tempo real, comunicação UDP nativa e controle de múltiplos periféricos via \gls{I2C}, conforme validado nos testes de arquitetura descritos na \autoref{subsec:evolucao-decisoes-comunicacao}. O diagrama elétrico completo das conexões do Raspberry Pi 4 com todos os componentes do sistema está disponível no \autoref{apendice:diagrama-rpi}.

O software embarcado foi desenvolvido em Python 3.11.2 utilizando o editor Visual Studio Code, aproveitando bibliotecas nativas para controle de GPIO, comunicação I2C e captura de vídeo via interface \gls{CSI}. A \autoref{tab:bibliotecas-rpi} apresenta as principais bibliotecas utilizadas no desenvolvimento do software embarcado.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:bibliotecas-rpi} Bibliotecas Python utilizadas no Raspberry Pi}
\IBGEtab{}{
\begin{tabular}{p{4.5cm}p{10cm}}
\toprule
\textbf{Biblioteca} & \textbf{Função} \\
\midrule
picamera2 & Captura de vídeo via interface CSI com codificação MJPEG por hardware \\
smbus2 & Comunicação I2C direta com sensores BMI160, ADS1115 e INA219 \\
adafruit-circuitpython-pca9685 & Controle do driver \gls{PWM} PCA9685 para acionamento de servos \\
adafruit-circuitpython-servokit & Abstração de alto nível para controle de servomotores \\
RPi.GPIO & Controle de pinos GPIO para \gls{ponteh} BTS7960 do motor DC \\
numpy & Processamento numérico de dados de sensores e cálculos de telemetria \\
socket & Comunicação UDP nativa para transmissão de dados ao cliente \\
\bottomrule
\end{tabular}
}{
\Fonte{elaborado pelo autor.}
}
\end{table}

\subsection{Especificações dos Componentes do Veículo}
\label{subsec:componentes-veiculo}

A \autoref{tab:componentes-veiculo} apresenta os componentes embarcados no veículo teleoperado, responsáveis pelo controle de propulsão, sensoriamento e comunicação via UDP.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:componentes-veiculo} Especificações dos componentes do veículo teleoperado}
\IBGEtab{}{%
	\begin{tabular}{p{3.5cm}p{6cm}p{6cm}}
		\toprule
		Componente & Especificação & Função no Sistema \\
		\midrule \midrule
		Raspberry Pi 4 Model B & Broadcom BCM2711, Quad core Cortex-A72 64-bit @ 1.8GHz, 8GB RAM & Núcleo de controle e comunicação do veículo, servidor UDP, processamento de vídeo e controle de sensores \\
		\midrule
		Câmera OV5647 & 5MP, 2592×1944 pixels, vídeo até 1080p/30fps, interface CSI & Captura de vídeo em 640×480/30fps para transmissão via UDP \\
		\midrule
		Sensor BMI160 \cite{bosch2015bmi160} & \gls{IMU} 6 eixos, ±4g/±500°/s, 16 bits, I2C, 100Hz sampling & Detecção de \glspl{forcag}, aceleração e velocidade angular para force feedback \\
		\midrule
		Motor DC 775 & 24V, 12.000 RPM, com transmissão manual de 5 marchas & Propulsão principal do veículo com zonas de eficiência F1 \\
		\midrule
		Ponte H BTS7960 \cite{infineon2013btn7960} & 5.5--27Vdc, corrente contínua 40A, proteção térmica integrada & Controle bidirecional de velocidade do motor de propulsão \\
		\midrule
		Servo MG996R (3x) & 4.8--7.2V, torque 11kg.cm, rotação 180°, velocidade 0.14s/60° & Controle de direção e sistema de freio dianteiro/traseiro \\
		\midrule
		PCA9685 PWM Driver \cite{nxp2015pca9685} & 16 canais, 12 bits, I2C, endereço \texttt{0x40} & Controle de servos (freio dianteiro, traseiro e direção) \\
		\midrule
		ADS1115 \gls{ADC} \cite{ti2018ads1115} & 16 bits, 4 canais, I2C, endereço \texttt{0x48} & Monitoramento de corrente via sensores ACS758 \\
		\midrule
		INA219 \cite{ti2015ina219} & Sensor corrente/tensão, I2C, endereço \texttt{0x41} & Monitoramento de energia do Raspberry Pi \\
		\midrule
		Sensor DS18B20 \cite{maxim2019ds18b20} & Digital 1-Wire, $-55$°C a $+125$°C, precisão $\pm0{,}5$°C & Monitoramento de temperatura do motor e eletrônica \\
		\midrule
		ACS758 100A \cite{allegro2018acs758} & Sensor Hall, sensibilidade 20mV/A, largura de banda 120kHz & Medição de corrente do motor DC 775 via ADS1115 \\
		\midrule
		ACS758 50A (2x) \cite{allegro2018acs758} & Sensor Hall, sensibilidade 40mV/A, largura de banda 120kHz & Medição de corrente do Raspberry Pi e servos via ADS1115 \\
		\midrule
		Regulador XL4015 \cite{xlsemi2017xl4015} & Step-down 8--36V para 1.25--32V, 5A, eficiência 96\% & Alimentação 5V do Raspberry Pi a partir da bateria \\
		\midrule
		UBEC 15A & 6--12S entrada, 5.25V saída, 15A contínuo, 30A pico & Alimentação dos servos MG996R \\
		\midrule
		Bateria \gls{LiPo} 3S & Turnigy Graphene 6000mAh, 11.1V, 75C descarga & Fonte de energia principal do veículo \\
		\midrule
		Caixa Diferencial HSP 1:10 & Modelo 94111/94123, relação 02051 & Transmissão diferencial para rodas traseiras \\
		\midrule
		Rolamento Unidirecional CSK8PP & $8\times22\times9$mm, uma direção de rotação & Proteção contra torque reverso no eixo do motor de propulsão \\
		\midrule
		Amortecedores RC 1:10 & Compatível Axial SCX10/TRX4, óleo ajustável & Suspensão do veículo com amortecimento ajustável \\
		\midrule
		Chassi FV01 & Escala 1:5 (modificada), impressão 3D em \gls{PLA}, pneus de borracha & Estrutura do veículo com suspensão push rod e aerodinâmica funcional \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

\subsection{Chassi e Estrutura}
\label{subsec:chassi-estrutura-veiculo}

O veículo utiliza o chassi FV01, um modelo de carro de Fórmula 1 projetado para impressão 3D por \citeonline{velocityprojects2024fv01}. O modelo original possui escala 1:7, porém foi modificado para escala 1:5 neste projeto para acomodar o Raspberry Pi 4, sensores, drivers e demais componentes eletrônicos. O chassi foi impresso em PLA com pneus de borracha para melhor aderência.

O modelo apresenta características que o tornam adequado para teleoperação com feedback háptico. A suspensão push rod independente reproduz o comportamento de carros de F1 reais, permitindo detecção precisa de forças G pelo sensor BMI160. O diferencial operacional proporciona comportamento realista em curvas, enquanto a modularidade do projeto facilita manutenção e substituição de peças.

A impressão das peças do chassi foi realizada em uma impressora Creality Ender 3 S1, equipada com extrusora direta Sprite de engrenagem dupla e nivelamento automático CR Touch de 16 pontos. A impressora possui volume de construção de 220 $\times$ 220 $\times$ 270 mm, resolução mínima de 0,05 mm e velocidade máxima de 150 mm/s, sendo compatível com diversos materiais como PLA, PETG, TPU e ABS\@. O fatiamento foi realizado utilizando o software Ultimaker Cura 5.11 \cite{ultimaker2024cura} com perfil de qualidade padrão. A \autoref{tab:config-impressao-3d} apresenta os principais parâmetros de impressão utilizados, selecionados para balancear resistência mecânica, tempo de impressão e consumo de material.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:config-impressao-3d} Parâmetros de impressão 3D do chassi FV01}
\IBGEtab{}{%
	\begin{tabular}{p{5cm}p{4cm}p{6cm}}
		\toprule
		Parâmetro & Valor & Observação \\
		\midrule \midrule
		Altura de camada & 0,2 mm & Qualidade padrão \\
		\midrule
		Espessura de parede & 0,8 mm & 2 linhas de parede \\
		\midrule
		Densidade de preenchimento & 15\% & Padrão Cubic Subdivision \\
		\midrule
		Temperatura de impressão & 210°C & 215°C na camada inicial \\
		\midrule
		Temperatura da mesa & 60°C & --- \\
		\midrule
		Velocidade de impressão & 60 mm/s & 25 mm/s na camada inicial \\
		\midrule
		Velocidade de deslocamento & 150 mm/s & --- \\
		\midrule
		Suporte & Tree & Ângulo de overhang 45° \\
		\midrule
		Adesão à mesa & Raft & Margem de 5 mm, 2 camadas \\
		\midrule
		Resfriamento & 100\% & Ventoinha ativada \\
		\midrule
		Retração & 0,8 mm & Velocidade de 40 mm/s \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

A densidade de preenchimento de 15\% com padrão Cubic Subdivision foi escolhida por oferecer boa resistência estrutural com economia de material, enquanto o suporte tipo Tree minimiza o contato com a superfície da peça, facilitando a remoção e melhorando o acabamento. O uso de Raft como adesão à mesa garante estabilidade durante a impressão de peças maiores, evitando empenamento nas bordas. A \autoref{fig:chassi-fv01} apresenta o modelo original do chassi FV01.

\begin{figure}[!ht]
	\captionsetup{width=16cm}
	\Caption{\label{fig:chassi-fv01} Modelo do chassi FV01 projetado para impressão 3D}
	\UFCfig{}{
		\includegraphics[width=12cm]{figuras/FV01-1}
	}{
		\Fonte{\citeonline{velocityprojects2024fv01}.}
	}
\end{figure}

Para realizar as modificações de escala e planejar a disposição interna dos componentes, utilizou-se o Tinkercad \cite{autodesk2024tinkercad}, uma ferramenta de modelagem 3D gratuita baseada em navegador. A \autoref{fig:tinkercad-layout} apresenta a simulação realizada, onde a bateria LiPo 3S (em vermelho) ocupa a região central inferior e o motor DC 775 com a transmissão (em laranja) está posicionado na parte traseira. Essa simulação prévia demonstrou que a escala 1:5 proporciona espaço adequado para os demais componentes eletrônicos.

\begin{figure}[!ht]
	\captionsetup{width=16cm}
	\Caption{\label{fig:tinkercad-layout} Simulação no Tinkercad da organização interna dos componentes no chassi FV01 modificado}
	\UFCfig{}{
		\includegraphics[width=14cm]{figuras/thinckercad}
	}{
		\Fonte{elaborado pelo autor.}
	}
\end{figure}

\subsection{Sistema de Sensoriamento}
\label{subsec:sensoriamento-veiculo}

O veículo incorpora múltiplos sensores para captura de dados em tempo real, transmitidos ao cliente via UDP para processamento e geração de feedback háptico.

\subsubsection{Câmera OV5647}

A câmera OV5647 conectada via interface CSI captura vídeo em resolução 640x480 a 30 \gls{FPS}. O stream de vídeo é codificado em MJPEG (Motion JPEG), onde cada frame é comprimido independentemente como imagem JPEG. Essa escolha foi motivada pela robustez contra perda de pacotes UDP: enquanto codecs como H.264 utilizam P-frames que dependem de frames anteriores (causando distorção em cascata quando há perda de pacotes), o MJPEG transmite frames independentes, limitando o impacto de perdas a um único frame. O trade-off é maior uso de banda (aproximadamente 4x mais que H.264), compensado pela qualidade de imagem consistente e simplicidade de decodificação via OpenCV.

\subsubsection{Sensor IMU BMI160}

O sensor inercial BMI160 conectado via barramento I2C (endereço \texttt{0x68}) fornece dados de aceleração (3 eixos) e velocidade angular (3 eixos) a 100Hz. A configuração utiliza faixa de $\pm$4g para acelerômetro e $\pm$500°/s para giroscópio, adequadas para captura de forças G em manobras típicas de veículos RC. Os dados são transmitidos ao cliente em formato JSON via UDP, onde são processados para cálculo de force feedback e estimativa de velocidade.

\subsubsection{Monitoramento de Energia}

O sistema de monitoramento de energia utiliza sensores ACS758 (50A e 100A) conectados ao ADC ADS1115 (endereço \texttt{0x48}) para medição de corrente, e sensor INA219 (endereço \texttt{0x41}) para monitoramento de tensão e corrente do Raspberry Pi. Esses dados permitem análise de consumo energético e detecção de anomalias durante operação.

\subsection{Controle de Propulsão e Direção}
\label{subsec:propulsao-direcao-veiculo}

O sistema de propulsão utiliza motor DC 775 de 24V controlado por ponte H BTS7960, enquanto direção e freios são acionados por servos MG996R através do driver PWM PCA9685 (endereço \texttt{0x40}).

\subsubsection{Motor de Propulsão}

O motor DC 775 opera com transmissão manual de 5 marchas, simulando comportamento de veículo real. O controle de velocidade é realizado via PWM através do driver BTS7960. O sistema implementa zonas de eficiência inspiradas em veículos de Fórmula 1, onde cada marcha possui uma faixa ideal de operação em termos de PWM do motor. Operar fora dessa faixa resulta em penalização na taxa de aceleração, calculada conforme a equação:

\begin{equation}
\label{eq:taxa-aceleracao}
Taxa_{acel} = \frac{100\%}{T_{base}} \times M_{zona}
\end{equation}

\noindent onde $T_{base} = 5s$ é o tempo base para atingir 100\% do PWM, e $M_{zona}$ é o multiplicador da zona de eficiência: $M_{IDEAL} = 1.0$, $M_{SUB} = 0.1$ (10× mais lento), e $M_{RUIM} = 0.04$ (25× mais lento). Isso resulta em taxas de 20\%/s na zona IDEAL, 2\%/s na zona SUBÓTIMA e 0.8\%/s na zona RUIM, conforme ilustrado na \autoref{fig:taxa-aceleracao-zonas}.

\begin{figure}[!ht]
	\captionsetup{width=16cm}
	\Caption{\label{fig:taxa-aceleracao-zonas} Taxa de aceleração por zona de eficiência}
	\UFCfig{}{
		\includegraphics[width=12cm]{figuras/taxa_aceleracao_zonas}
	}{
		\Fonte{elaborado pelo autor.}
	}
\end{figure}

A \autoref{fig:zonas-eficiencia-marchas} ilustra as zonas de eficiência por marcha. Cada marcha possui uma zona IDEAL (verde) onde a aceleração ocorre em taxa normal, uma zona SUBÓTIMA (laranja) com aceleração 10 vezes mais lenta, e uma zona RUIM (vermelho) com aceleração 25 vezes mais lenta. Os limitadores de PWM restringem a potência máxima disponível em cada marcha: 15\% na 1ª, 30\% na 2ª, 60\% na 3ª, 90\% na 4ª e 100\% na 5ª marcha. As marchas 1ª e 2ª dividem a faixa de 0-30\% do PWM (marchas lentas), as marchas 3ª e 4ª dividem a faixa de 30-90\% (marchas médias e altas), enquanto a 5ª marcha possui zona IDEAL ampla de 70-100\% (velocidade pura). Esse sistema força o operador a progredir pelas marchas para atingir velocidade máxima, reproduzindo o comportamento de uma transmissão real.

\begin{figure}[!ht]
	\captionsetup{width=16cm}
	\Caption{\label{fig:zonas-eficiencia-marchas} Zonas de eficiência F1 por marcha}
	\UFCfig{}{
		\includegraphics[width=14cm]{figuras/zonas_eficiencia_marchas}
	}{
		\Fonte{elaborado pelo autor.}
	}
\end{figure}

\subsubsection{Sistema de Direção e Freios}

A direção utiliza servo MG996R no canal 2 do PCA9685, com rotação de 0° a 180°. O sistema de freio emprega dois servos MG996R (canais 0 e 1) para controle independente de freio dianteiro e traseiro, permitindo ajuste de balanceamento de frenagem. O balanceamento padrão é 60\% dianteiro e 40\% traseiro, ajustável via comandos do cliente.

\subsection{Proteção contra Força Eletromotriz de Retorno}
\label{subsec:protecao-backemf-veiculo}

Quando um motor DC gira, seja por acionamento elétrico ou por força mecânica externa, ele atua como gerador e produz uma tensão conhecida como \gls{backemf}. No contexto deste projeto, essa situação ocorre tanto no veículo (quando as rodas giram livremente com motor desligado) quanto no simulador (quando o operador gira o volante manualmente).

O driver BTS7960 foi selecionado para ambos os sistemas, veículo e simulador, especificamente por possuir proteções integradas contra esse fenômeno. Conforme especificado no datasheet do fabricante \citeonline{infineon2013btn7960}, o circuito integrado BTN7960 (chip utilizado no módulo BTS7960) incorpora capacidade de \textit{active freewheeling} com frequência PWM de até 25 kHz, minimizando a dissipação de potência nos diodos integrados quando o motor opera como gerador. Além disso, o BTN7960 oferece proteção contra sobrecorrente, proteção térmica com desligamento automático em temperaturas elevadas e proteção contra curto-circuito.

No veículo, uma proteção mecânica adicional foi implementada através de rolamento unidirecional no eixo de transmissão. Esse componente permite que as rodas girem livremente sem transmitir rotação reversa ao motor, reduzindo a geração de back-EMF quando o veículo está em movimento com motor desligado. No simulador, essa proteção mecânica não é aplicável porque o motor de force feedback necessita operar em ambas as direções para simular resistência no volante, dependendo exclusivamente das proteções eletrônicas do BTS7960.

Essa arquitetura de proteção elimina a necessidade de componentes externos adicionais, como diodos flyback ou capacitores de supressão de transientes, simplificando o projeto eletrônico e aumentando a confiabilidade do sistema.

\subsection{Arquitetura Multi-Thread}
\label{subsec:multithread-veiculo}

O software embarcado no Raspberry Pi foi refatorado de uma arquitetura sequencial para uma arquitetura multi-thread, permitindo que cada subsistema opere de forma independente e em sua taxa ideal de amostragem. Na arquitetura sequencial original, o loop principal executava todas as operações em sequência (captura de frame, leitura de sensores, transmissão de dados), resultando em latência acumulada onde o componente mais lento limitava todo o sistema.

A arquitetura multi-thread implementada utiliza cinco threads principais: a thread de câmera opera a 30Hz para captura de frames da OV5647; a thread de sensores opera a 100Hz para leitura do BMI160 e envio direto pela porta UDP 9997; a thread de energia opera a 10Hz para monitoramento via ADS1115 e INA219; a thread de temperatura opera a 1Hz para leitura do DS18B20; e a thread de transmissão principal verifica dados a 120Hz, consolidando e enviando pacotes pela porta 9999 quando há novos frames disponíveis (efetivamente 30Hz). Essa separação permite que a captura de vídeo não atrase a leitura de sensores e vice-versa, reduzindo a latência de sensores de aproximadamente 33ms (espera por frame) para aproximadamente 10ms (envio direto pela porta dedicada).

A comunicação entre threads utiliza filas \gls{threadsafe} (classe \texttt{Queue} do Python) para transferência de dados e locks (\texttt{threading.Lock}) para proteção de variáveis compartilhadas. Cada gerenciador de componente implementa seu próprio lock interno para garantir acesso seguro em ambiente concorrente. A thread de transmissão consolida os dados mais recentes de todas as threads de aquisição antes de cada envio, garantindo pacotes com informações sincronizadas.

O tratamento de erros é isolado por thread, onde exceções em um subsistema não afetam os demais. Cada thread implementa tratamento de exceção com logging e continuação de execução, evitando que falhas temporárias (como timeout de I2C) interrompam todo o sistema. O shutdown coordenado define uma flag de parada, aguarda cada thread finalizar com timeout de 2 segundos, para componentes na ordem inversa de dependência e libera recursos de GPIO, I2C e sockets.

% ============================================================================
% ARQUITETURA DO SIMULADOR (ESP32)
% ============================================================================
\section{Arquitetura do Simulador (ESP32)}
\label{sec:arquitetura-simulador}

O ESP32 DevKit V1 com processador dual-core Xtensa LX6 a 240MHz constitui o controlador do simulador, responsável pela leitura de encoders, controle do motor de force feedback e comunicação serial com o cliente PC. A escolha do ESP32 sobre o Arduino Mega foi motivada pelo processamento superior, conforme demonstrado nos testes de latência da \autoref{subsec:evolucao-decisoes-comunicacao}. O diagrama elétrico completo das conexões do ESP32 com todos os componentes do simulador está disponível no \autoref{apendice:diagrama-esp32}.

O firmware foi desenvolvido em C++ utilizando o Arduino IDE, aproveitando o framework Arduino para ESP32 que fornece abstrações para controle de GPIO, interrupções de hardware e comunicação serial. A \autoref{tab:bibliotecas-esp32} apresenta as bibliotecas utilizadas no desenvolvimento do firmware.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:bibliotecas-esp32} Bibliotecas C++ utilizadas no ESP32}
\IBGEtab{}{
\begin{tabular}{p{4cm}p{10.5cm}}
\toprule
\textbf{Biblioteca} & \textbf{Função} \\
\midrule
Arduino.h & Framework base com abstrações para GPIO, PWM e temporização \\
EEPROM.h & Armazenamento persistente de dados de calibração dos encoders \\
FreeRTOS & Sistema operacional de tempo real para execução dual-core \\
HardwareSerial & Comunicação serial USB com o cliente PC a 115200 baud \\
\bottomrule
\end{tabular}
}{
\Fonte{elaborado pelo autor.}
}
\end{table}

\subsection{Especificações dos Componentes do Simulador}
\label{subsec:componentes-simulador}

A \autoref{tab:componentes-simulador} apresenta os componentes do simulador de controle, responsáveis pela interface física com o operador e geração de feedback háptico.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:componentes-simulador} Especificações dos componentes do simulador de controle}
\IBGEtab{}{%
	\begin{tabular}{p{3.5cm}p{6cm}p{6cm}}
		\toprule
		Componente & Especificação & Função no Sistema \\
		\midrule \midrule
		ESP32 DevKit V1 \cite{espressif2024esp32} & Dual-core Xtensa LX6 @ 240MHz, 520KB SRAM, 4MB Flash, WiFi/Bluetooth & Controle de encoders, force feedback via BTS7960 e comunicação serial USB com cliente PC \\
		\midrule
		Encoder LPD3806-600BM (3x) & 600 \gls{PPR}, saída A/B \gls{quadratura}, 5--24V & Leitura de posição de acelerador, freio e direção \\
		\midrule
		Motor DC 775 & 24V, 12.000 RPM, controlado por BTS7960 & Geração de force feedback no volante \\
		\midrule
		Ponte H BTS7960 \cite{infineon2013btn7960} & 5.5--27Vdc, corrente contínua 40A, proteção térmica integrada & Controle bidirecional do motor de force feedback \\
		\midrule
		Amortecedores RC 1:10 & Compatível Axial SCX10/TRX4, óleo ajustável & Amortecimento dos pedais de acelerador e freio \\
		\midrule
		Botões Push (2x) & Normalmente aberto, com resistor pull-up interno & Controle de troca de marchas (subir/descer) \\
		\midrule
		Fonte ATX 500W BRX & 500W bivolt manual, cooler 80mm, proteção contra curto-circuito, sobrecarga e superaquecimento & Alimentação principal do simulador \\
		\midrule
		Placa Breakout ATX 24 pinos & Saídas +3,3V, +5V, +12V, -12V e 5VSB, 6 portas USB 5V/2A, terminais 20A, interruptor de toque & Distribuição de energia para ESP32, encoders, motor e atuadores \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

O volante do simulador utiliza uma réplica em escala real do volante da McLaren MP4-30 de 2015, modelo 3D composto por 129 peças impressas em PLA, projetado por \citeonline{nacho3d2020volante}. A estrutura foi adaptada para acomodar o encoder rotacional de direção e o motor DC 775 de force feedback, mantendo a ergonomia e aparência característica dos volantes de Fórmula 1.

\subsection{Leitura de Encoders Rotacionais}
\label{subsec:encoders-simulador}

O simulador utiliza três encoders rotacionais LPD3806-600BM-G5-24C com resolução de 600 pulsos por revolução (PPR) e saída em quadratura (canais A e B). A leitura é realizada via interrupções de hardware, garantindo captura precisa mesmo em rotações rápidas.

Os valores dos encoders são normalizados para porcentagem (0--100\% para acelerador e freio) ou ângulo (-100\% a +100\% para direção) e transmitidos ao cliente a 100Hz via serial USB.

\subsection{Controle de Marchas}
\label{subsec:marchas-simulador}

O sistema de marchas utiliza dois botões push para subir e descer marcha. A detecção é feita por polling com \gls{debounce} de software, evitando acionamentos múltiplos. Eventos de troca de marcha são transmitidos ao cliente como mensagens \texttt{GEAR\_UP} e \texttt{GEAR\_DOWN}. O \autoref{alg:debounce-marchas} apresenta o algoritmo de leitura com debounce implementado.

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:debounce-marchas}Leitura de botão com debounce}
	\Entrada{pino, estado\_anterior, tempo\_anterior}
	\Saida{pressionado}
	\Inicio{
		leitura $\leftarrow$ digitalRead(pino)\;
		pressionado $\leftarrow$ falso\;
		tempo\_atual $\leftarrow$ millis()\;
		// Verifica se o estado do botão mudou\;
		\Se{leitura $\neq$ estado\_anterior}{
			// Verifica se passou o tempo de debounce (50ms)\;
			\Se{(tempo\_atual - tempo\_anterior) > 50}{
				// Detecta transição HIGH $\rightarrow$ LOW (pressão)\;
				\Se{leitura = LOW \textbf{e} estado\_anterior = HIGH}{
					pressionado $\leftarrow$ verdadeiro\;
				}
				estado\_anterior $\leftarrow$ leitura\;
			}
			tempo\_anterior $\leftarrow$ tempo\_atual\;
		}
	}
\end{algorithm}

\subsection{Sistema de Force Feedback}
\label{subsec:ff-simulador}

O motor DC 775 de 24V do volante é controlado por ponte H BTS7960, recebendo comandos de intensidade e direção do cliente PC via serial USB. O protocolo de comunicação utiliza formato texto:

\begin{verbatim}
FF_MOTOR:ESQUERDA:45    - 45% de força anti-horária
FF_MOTOR:DIREITA:80     - 80% de força horária
FF_MOTOR:NEUTRO:0       - Libera o volante
\end{verbatim}

A proteção contra back-EMF do BTS7960, descrita na \autoref{subsec:protecao-backemf-veiculo}, também se aplica ao motor de force feedback, permitindo que o operador gire o volante livremente quando o motor não está acionado.

\subsection{Calibração de Encoders}
\label{subsec:calibracao-simulador}

A calibração dos encoders é necessária porque cada unidade pode apresentar variações de fábrica nos valores de contagem, e a montagem física no simulador pode resultar em posições de repouso diferentes das esperadas. O processo de calibração determina os limites operacionais de cada controle (valor mínimo quando totalmente solto, valor máximo quando totalmente pressionado) e, no caso da direção, o ponto central correspondente ao volante reto.

Os valores calibrados são armazenados na \gls{EEPROM} do ESP32, uma memória não volátil que preserva os dados mesmo quando o dispositivo é desligado, eliminando a necessidade de recalibração a cada inicialização. O protocolo de calibração opera via comunicação serial entre o cliente PC e o ESP32:

\begin{enumerate}
	\item O cliente PC envia comando de início especificando o controle: \texttt{CAL\_START:THROTTLE}, \texttt{CAL\_START:BRAKE} ou \texttt{CAL\_START:STEERING}
	\item O ESP32 entra em modo de calibração e transmite os valores brutos do encoder a 100Hz (exemplo: \texttt{CAL\_THROTTLE:2847}), permitindo que o cliente exiba a leitura em tempo real
	\item O operador move fisicamente o controle para suas posições extremas (pedal totalmente solto e totalmente pressionado, ou volante totalmente à esquerda e à direita), enquanto o cliente registra os valores mínimo e máximo observados
	\item O cliente envia os valores calibrados para armazenamento: \texttt{CAL\_SAVE:THROTTLE:min:max} para controles unipolares (acelerador e freio) ou \texttt{CAL\_SAVE:STEERING:left:center:right} para controle bipolar (direção)
	\item O ESP32 armazena os valores na EEPROM e confirma o sucesso da operação: \texttt{CAL\_COMPLETE:THROTTLE}
\end{enumerate}

A estrutura de dados na EEPROM utiliza mecanismos de validação para detectar corrupção de dados ou ausência de calibração prévia. O magic number (\texttt{0xCAFE}) é um valor fixo gravado junto aos dados de calibração; se esse valor não for encontrado durante a leitura, o sistema identifica que a EEPROM não contém calibração válida e utiliza valores padrão. O checksum é uma soma de verificação calculada sobre os dados armazenados; caso o valor lido não corresponda ao checksum esperado, indica-se corrupção dos dados. Cada encoder possui área reservada de 16 bytes na EEPROM (endereços 0, 16 e 32 para acelerador, freio e direção, respectivamente), totalizando 48 bytes de armazenamento persistente.

\subsection{Comunicação Serial USB}
\label{subsec:serial-simulador}

A comunicação com o cliente PC utiliza USB serial a 115200 baud, operando em modo \gls{fullduplex}. O ESP32 transmite dados de encoders e eventos de marcha, enquanto recebe comandos de force feedback e calibração. A taxa de atualização de 100Hz (10ms) garante responsividade adequada para controle em tempo real.

% ============================================================================
% ARQUITETURA DO CLIENTE (PC)
% ============================================================================
\section{Arquitetura do Cliente (PC)}
\label{sec:arquitetura-cliente}

O cliente PC atua como hub central do sistema, recebendo dados do veículo via UDP, processando telemetria, calculando force feedback e transmitindo comandos para simulador e veículo. O software foi desenvolvido em Python 3.11.2 utilizando o editor Visual Studio Code, com interface gráfica Tkinter. O Python foi escolhido devido à facilidade de prototipagem e disponibilidade de bibliotecas para decodificação de vídeo, interface gráfica, processamento de imagens e comunicação. A \autoref{tab:bibliotecas-cliente} apresenta as principais bibliotecas utilizadas no desenvolvimento do cliente.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:bibliotecas-cliente} Bibliotecas Python utilizadas no cliente PC}
\IBGEtab{}{
\begin{tabular}{p{3.5cm}p{11cm}}
\toprule
\textbf{Biblioteca} & \textbf{Função} \\
\midrule
tkinter & Interface gráfica nativa com suporte a widgets e canvas para vídeo \\
opencv-python & Decodificação de frames MJPEG e aplicação de filtros de imagem \\
numpy & Processamento numérico de dados de telemetria e operações matriciais \\
cupy & Aceleração GPU para filtros PDI via \gls{CUDA} (opcional) \\
Pillow & Conversão de imagens OpenCV para formato compatível com Tkinter \\
pyserial & Comunicação serial com ESP32 para recepção de dados do simulador \\
socket & Comunicação UDP com Raspberry Pi para recepção de telemetria e vídeo \\
matplotlib & Renderização de gráficos de telemetria em tempo real \\
\bottomrule
\end{tabular}
}{
\Fonte{elaborado pelo autor.}
}
\end{table}

\subsection{Especificações da Estação Cliente}
\label{subsec:componentes-cliente}

A \autoref{tab:componentes-cliente} apresenta as especificações do computador utilizado como estação cliente, responsável pelo processamento de telemetria, decodificação de vídeo MJPEG e cálculo de algoritmos de force feedback.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:componentes-cliente} Especificações da estação cliente}
\IBGEtab{}{%
	\begin{tabular}{p{3.5cm}p{6cm}p{6cm}}
		\toprule
		Componente & Especificação & Função no Sistema \\
		\midrule \midrule
		Notebook & Acer Nitro V 15 ANV15-51 & Plataforma de desenvolvimento e execução do cliente \\
		\midrule
		Processador & Intel Core i5-13420H (13ª geração), 8 núcleos (4P+4E), 12 threads, até 4.6GHz & Processamento de telemetria, interface gráfica e algoritmos de force feedback \\
		\midrule
		GPU Dedicada & NVIDIA GeForce RTX 3050 6GB GDDR6 (GA107BM) & Aceleração de processamento de imagem e renderização da interface \\
		\midrule
		GPU Integrada & Intel UHD Graphics (Raptor Lake-P) & Renderização secundária e economia de energia \\
		\midrule
		Memória RAM & 32GB DDR5 & Buffers de vídeo, histórico de telemetria e estruturas de dados \\
		\midrule
		Armazenamento & WD SN770 NVMe + Kingston NV1 NVMe & Armazenamento de logs, datasets e código fonte \\
		\midrule
		Sistema Operacional & Arch Linux, Kernel 6.18.2-arch2-1 & Ambiente de desenvolvimento com baixa latência e controle total do sistema \\
		\midrule
		Conectividade & WiFi 6 (802.11ax), USB 3.0 & Comunicação UDP com veículo e serial USB com simulador ESP32 \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

\subsection{Interface Gráfica}
\label{subsec:interface-cliente}

A interface gráfica utiliza layout de duas colunas: telemetria à esquerda e vídeo/controles à direita, conforme ilustrado na \autoref{fig:interface-geral}. A viabilidade técnica do streaming em tempo real com Raspberry Pi foi demonstrada por \citeonline{shendge2023development}, conforme apresentado na fundamentação teórica.

\begin{figure}[!ht]
	\captionsetup{width=16cm}
	\Caption{\label{fig:interface-geral} Interface gráfica do console de controle}
	\UFCfig{}{
		\includegraphics[width=15cm]{figuras/interface-geral}
	}{
		\Fonte{elaborado pelo autor.}
	}
\end{figure}

A coluna esquerda apresenta o status da conexão UDP e serial, painel de instrumentos com zona de eficiência, marcha atual, informações de energia, bateria e temperatura, dados brutos e físicos do sensor BMI160, forças G calculadas, velocidade estimada e componentes do cálculo de force feedback. A coluna direita exibe o vídeo da câmera em tempo real, filtros de processamento de imagem e gráficos de telemetria F1.

O painel de instrumentos exibe a porcentagem dentro da zona IDEAL de eficiência, marcha atual, posição do acelerador e velocidade estimada, atualizados em tempo real conforme dados recebidos do veículo e simulador. A visualização de vídeo utiliza OpenCV para decodificação MJPEG e Pillow para renderização no canvas Tkinter.

\subsection{Filtros de Processamento Digital de Imagens}
\label{subsec:filtros-pdi}

O cliente implementa um sistema de filtros de \gls{PDI} combináveis, permitindo ao operador ativar múltiplos filtros simultaneamente via checkboxes na interface. Os filtros são aplicados em ordem otimizada para maximizar a qualidade visual do vídeo recebido do veículo.

A \autoref{tab:filtros-pdi} apresenta os filtros disponíveis no sistema, baseados em técnicas clássicas de processamento de imagens conforme \citeonline{gonzalez2010processamento}.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:filtros-pdi} Filtros de processamento digital de imagens disponíveis no cliente}
\IBGEtab{}{
\begin{tabular}{p{2.5cm}p{3.5cm}p{6.5cm}c}
\toprule
\textbf{Filtro} & \textbf{Técnica} & \textbf{Descrição} & \textbf{GPU} \\
\midrule
Sharpen & Máscara \gls{laplaciano} 3×3 & Aguça bordas usando operador de segunda derivada & Sim \\
Unsharp Mask & Subtração gaussiana & Realça detalhes subtraindo versão borrada da imagem & Sim \\
High-Boost & Laplaciano ponderado & Aguçamento com preservação de baixas frequências & Sim \\
CLAHE & Equalização adaptativa & Melhora contraste local com limite de amplificação & Não \\
Bilateral & Filtragem bilateral & Suaviza ruído preservando bordas & Não \\
Super-Res 2x & Supersampling & Anti-aliasing via upscale/downscale Lanczos & Sim \\
Brilho +/- & Ajuste HSV & Modifica canal V para ambientes claros/escuros & Sim \\
\bottomrule
\end{tabular}
}{
\Fonte{elaborado pelo autor.}
}
\end{table}

O sistema suporta aceleração por \gls{GPU} NVIDIA via biblioteca CuPy quando disponível, executando operações de \gls{convolucao} e transformações diretamente na placa de vídeo. Os filtros \gls{CLAHE} e Bilateral executam exclusivamente em \gls{CPU} devido à complexidade algorítmica que dificulta paralelização eficiente. O fallback automático para CPU garante funcionamento em sistemas sem GPU dedicada.

\subsection{Arquitetura Multi-Thread e Recepção de Dados}
\label{subsec:recepcao-cliente}

O cliente PC implementa uma arquitetura multi-thread para garantir processamento paralelo e responsividade da interface gráfica. A separação em threads especializadas permite que operações de I/O (rede e serial) não bloqueiem a renderização de vídeo ou a atualização da interface.

A thread principal executa o loop de eventos do Tkinter, responsável pela renderização da interface gráfica e atualização dos widgets em tempo real. A thread de rede opera como daemon e recebe pacotes UDP do veículo na porta 9999, decodificando frames MJPEG e dados de telemetria consolidados a aproximadamente 30Hz. A thread serial recebe dados dos encoders do simulador via USB a 100Hz, processando comandos de acelerador, freio, direção e troca de marchas. Adicionalmente, uma thread de sensores rápidos recebe exclusivamente dados do BMI160 na porta UDP 9997 a 100Hz, permitindo cálculo de force feedback com baixa latência.

A comunicação entre threads utiliza filas \gls{threadsafe} (\texttt{queue.Queue}) para transferência de dados à thread principal. Filas separadas são mantidas para logs, status de conexão, dados de sensores e frames de vídeo. A thread principal consome essas filas periodicamente via callbacks do Tkinter (\texttt{root.after()}), garantindo que atualizações de interface ocorram apenas na thread principal conforme exigido pelo toolkit gráfico.

O filtro por IP garante que apenas pacotes do veículo configurado sejam processados, ignorando tráfego de rede não relacionado. Essa arquitetura permite que o cliente mantenha taxa de atualização de interface de 30Hz para vídeo, 100Hz para dados de sensores e resposta imediata a comandos do operador, mesmo durante picos de processamento de filtros de imagem ou cálculos de force feedback.

\subsection{Algoritmos de Cálculo de Force Feedback}
\label{subsec:algoritmos-ff-cliente}

Os algoritmos de force feedback são executados no cliente, utilizando dados do sensor BMI160 recebidos do veículo para calcular intensidade e direção da força a ser aplicada no volante.

Embora algoritmos meta-heurísticos como LHHO e TLBO demonstrem vantagens conforme \citeonline{ayinla2024optimal}, optou-se por implementação direta dos algoritmos de force feedback devido às limitações computacionais e à necessidade de resposta em tempo real inferior a 5ms.

\subsubsection{Cálculo das Forças G}

O algoritmo para cálculo das forças G considera os valores de aceleração linear e velocidade angular obtidos do sensor BMI160:

\begin{equation}
\label{eq:forca-g-frontal-cliente}
G_{frontal} = \frac{acelera\text{ç}\tilde{a}o_{linear\_X}}{9.81}
\end{equation}

\begin{equation}
\label{eq:forca-g-lateral-cliente}
G_{lateral} = \frac{acelera\text{ç}\tilde{a}o_{linear\_Y}}{9.81}
\end{equation}

\subsubsection{Algoritmos de Controle de Force Feedback}
\label{subsubsec:algoritmos-force-feedback}

O sistema utiliza os dados de aceleração linear do sensor BMI160 para calcular as forças G experimentadas pelo veículo. O acelerômetro fornece diretamente os valores de aceleração nos três eixos, permitindo cálculo preciso das forças G frontal (eixo X) e lateral (eixo Y). Essa abordagem segue o trabalho de \citeonline{dreger2024evaluation}, que demonstraram que feedback em tempo real melhora significativamente a precisão do operador.

O \autoref{alg:calcular-forcas-g} apresenta a implementação do cálculo de forças G. A \autoref{fig:ff-forcas-g} ilustra graficamente a relação entre aceleração e força G calculada.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.95\linewidth]{figuras/ff_charts/ff_forcas_g.png}
	\Caption{\label{fig:ff-forcas-g} Cálculo das forças G frontal e lateral a partir dos dados do acelerômetro}
\end{figure}

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:calcular-forcas-g}Cálculo das forças G}
	\Entrada{accel\_x, accel\_y, accel\_z}
	\Saida{g\_frontal, g\_lateral, g\_vertical}
	\Inicio{
		// Leitura dos sensores (valores em m/s²)\;
		accel\_x $\leftarrow$ ler\_acelerometro\_x()\;
		accel\_y $\leftarrow$ ler\_acelerometro\_y()\;
		accel\_z $\leftarrow$ ler\_acelerometro\_z()\;
		// Cálculo das forças G\;
		g\_frontal $\leftarrow$ accel\_x / 9.81\;
		g\_lateral $\leftarrow$ accel\_y / 9.81\;
		g\_vertical $\leftarrow$ (accel\_z - 9.81) / 9.81\;
	}
\end{algorithm}

\subsubsection{Componentes do Force Feedback da Direção}

O sistema de force feedback da direção combina três componentes principais, conforme ilustrado na \autoref{fig:ff-componentes}: força lateral (curvas), rotação yaw e mola de centralização. A força base é calculada como a soma dos três componentes, limitada a 100\%.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{figuras/ff_charts/ff_componentes.png}
	\Caption{\label{fig:ff-componentes} Componentes do force feedback da direção: lateral, yaw e centralização}
\end{figure}

O componente lateral representa a força experimentada pelo volante durante curvas, proporcional à força G lateral. O componente yaw captura a rotação do veículo em torno do eixo vertical, detectada pelo giroscópio. O componente de centralização simula a mola de retorno do sistema de direção, aplicando força proporcional ao ângulo de esterçamento para retornar o volante à posição central.

A \autoref{fig:ff-cenarios} apresenta a contribuição de cada componente em cenários típicos de condução, desde reta em velocidade constante até curvas no limite de aderência.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\linewidth]{figuras/ff_charts/ff_cenarios.png}
	\Caption{\label{fig:ff-cenarios} Contribuição dos componentes de force feedback por cenário de condução}
\end{figure}

O algoritmo é executado no cliente PC e envia comandos para o motor DC 775 do simulador via ESP32:

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:ff-direcao}Cálculo do force feedback da direção}
	\Entrada{g\_lateral, gyro\_z, angulo\_direcao, sensibilidade, friccao, filtro, damping}
	\Saida{intensidade\_ff, direcao\_ff}
	\Inicio{
		// Componente 1: Força lateral (curvas) - máximo 100\%\;
		componente\_lateral $\leftarrow$ minimo(abs(g\_lateral) $\times$ 50, 100)\;
		// Componente 2: Rotação yaw - máximo 50\%\;
		componente\_yaw $\leftarrow$ minimo(abs(gyro\_z) / 60.0 $\times$ 50, 50)\;
		// Componente 3: Mola de centralização - máximo 40\%\;
		razao\_angulo $\leftarrow$ abs(angulo\_direcao) / 100.0\;
		componente\_centragem $\leftarrow$ razao\_angulo $\times$ 40\;
		// Força base combinada (0-100\%)\;
		ff\_base $\leftarrow$ minimo(componente\_lateral + componente\_yaw + componente\_centragem, 100)\;
		// Aplica sensibilidade\;
		ff\_ajustado $\leftarrow$ ff\_base $\times$ sensibilidade\;
		// Aplica fricção baseada na rotação\;
		forca\_friccao $\leftarrow$ minimo(abs(gyro\_z) / 100.0, 1.0) $\times$ friccao $\times$ 30\;
		ff\_ajustado $\leftarrow$ minimo(ff\_ajustado + forca\_friccao, 100.0)\;
		// Aplica filtro (suavização exponencial)\;
		ff\_ajustado $\leftarrow$ ff\_ajustado $\times$ (1.0 - filtro) + ff\_filtrado\_anterior $\times$ filtro\;
		// Aplica damping (média móvel)\;
		intensidade\_ff $\leftarrow$ ff\_ajustado $\times$ (1.0 - damping) + ff\_anterior $\times$ damping\;
		// Determina direção do force feedback\;
		valor\_direcao $\leftarrow$ (-angulo\_direcao) + (g\_lateral $\times$ 10) + gyro\_z\;
		\Se{valor\_direcao > 5}{direcao\_ff $\leftarrow$ "DIREITA"\;}
		\SenaoSe{valor\_direcao < -5}{direcao\_ff $\leftarrow$ "ESQUERDA"\;}
		\Senao{direcao\_ff $\leftarrow$ "NEUTRO"\;}
	}
\end{algorithm}

\subsubsection{Parâmetros Ajustáveis de Force Feedback}

O sistema permite ajuste em tempo real de quatro parâmetros que modificam a resposta do force feedback, conforme ilustrado na \autoref{fig:ff-parametros}. A sensibilidade (padrão 75\%) escala a intensidade geral da força. A fricção (padrão 30\%) adiciona resistência proporcional à velocidade angular do veículo, simulando o atrito dos pneus. O filtro (padrão 40\%) aplica suavização exponencial para eliminar oscilações de alta frequência. O damping (padrão 50\%) implementa média móvel para simular inércia mecânica do sistema de direção.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{figuras/ff_charts/ff_parametros.png}
	\Caption{\label{fig:ff-parametros} Efeito dos parâmetros ajustáveis no force feedback}
\end{figure}

\subsubsection{Determinação da Direção do Force Feedback}

A direção do force feedback é calculada combinando três componentes direcionais: centralização (força contrária ao ângulo de esterçamento), força lateral (proporcional à força G) e rotação yaw (velocidade angular). O valor resultante determina se a força será aplicada para esquerda, direita ou neutro, conforme ilustrado na \autoref{fig:ff-direcao}.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{figuras/ff_charts/ff_direcao.png}
	\Caption{\label{fig:ff-direcao} Cálculo da direção do force feedback e mapa de zonas}
\end{figure}

\subsubsection{Mapeamento PWM do Motor}

O comando de intensidade calculado (0-100\%) é transmitido via USB serial para o ESP32, que converte o valor para ciclo de trabalho PWM de 8 bits (0-255) através de mapeamento linear. A ponte H BTS7960 recebe o sinal PWM e aciona o motor DC 775 na direção correspondente.

\begin{equation}
\label{eq:pwm-saida}
PWM = \frac{intensidade \times 255}{100}
\end{equation}

\subsubsection{Cálculo de Velocidade por Integração}

A velocidade do veículo é estimada através da integração numérica da aceleração medida pelo sensor BMI160. Um fator de decaimento é aplicado para simular atrito e resistência do ar, conforme ilustrado na \autoref{fig:ff-velocidade}:

\begin{equation}
\label{eq:velocidade-integracao}
v(t) = v(t-1) + a \times \Delta t
\end{equation}

\begin{equation}
\label{eq:velocidade-decaimento}
v_{final} = v(t) \times fator_{decaimento}
\end{equation}

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{figuras/ff_charts/ff_velocidade.png}
	\Caption{\label{fig:ff-velocidade} Processo de integração de aceleração para estimativa de velocidade}
\end{figure}

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:calcular-velocidade}Cálculo de velocidade por integração}
	\Entrada{accel\_x, accel\_y, tempo\_atual}
	\Saida{velocidade\_total\_kmh}
	\Inicio{
		LIMIAR\_ACCEL $\leftarrow$ 0.3\;
		FATOR\_DECAIMENTO $\leftarrow$ 0.98\;
		LIMIAR\_VELOCIDADE $\leftarrow$ 0.1\;
		// Calcula delta time\;
		dt $\leftarrow$ tempo\_atual - tempo\_anterior\;
		tempo\_anterior $\leftarrow$ tempo\_atual\;
		// Filtra ruído da aceleração\;
		\Se{abs(accel\_x) < LIMIAR\_ACCEL}{accel\_x $\leftarrow$ 0\;}
		\Se{abs(accel\_y) < LIMIAR\_ACCEL}{accel\_y $\leftarrow$ 0\;}
		// Integração: v = v0 + a $\times$ dt\;
		velocidade\_x $\leftarrow$ velocidade\_x + accel\_x $\times$ dt\;
		velocidade\_y $\leftarrow$ velocidade\_y + accel\_y $\times$ dt\;
		// Aplica decaimento (simula atrito)\;
		velocidade\_x $\leftarrow$ velocidade\_x $\times$ FATOR\_DECAIMENTO\;
		velocidade\_y $\leftarrow$ velocidade\_y $\times$ FATOR\_DECAIMENTO\;
		// Zera velocidades muito pequenas\;
		\Se{abs(velocidade\_x) < LIMIAR\_VELOCIDADE}{velocidade\_x $\leftarrow$ 0\;}
		\Se{abs(velocidade\_y) < LIMIAR\_VELOCIDADE}{velocidade\_y $\leftarrow$ 0\;}
		// Calcula magnitude e converte para km/h\;
		velocidade\_ms $\leftarrow$ raiz(velocidade\_x$^2$ + velocidade\_y$^2$)\;
		velocidade\_total\_kmh $\leftarrow$ velocidade\_ms $\times$ 3.6\;
	}
\end{algorithm}

\subsection{Sistema de Telemetria em Tempo Real}
\label{subsec:telemetria-cliente}

O sistema de telemetria exibe gráficos em tempo real com visual inspirado nas interfaces de engenharia de equipes de Fórmula 1, utilizando a biblioteca Matplotlib integrada ao framework gráfico Tkinter. Os dados de sensores são armazenados em \glspl{buffercircular} implementados com estruturas \textit{deque} do Python, com capacidade máxima de 500 pontos. Essa capacidade representa aproximadamente 50 segundos de histórico considerando a taxa de atualização de 10Hz, permitindo ao operador visualizar tendências recentes sem consumo excessivo de memória. O \autoref{alg:atualizar-telemetria} apresenta o processo de atualização dos gráficos.

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:atualizar-telemetria}Atualização dos gráficos de telemetria}
	\Entrada{dados\_sensores}
	\Saida{graficos\_atualizados}
	\Inicio{
		MAX\_PONTOS $\leftarrow$ 500\;
		JANELA\_TEMPO $\leftarrow$ 30\;
		// Calcula tempo relativo desde o início\;
		tempo\_atual $\leftarrow$ tempo\_sistema() - tempo\_inicio\;
		// Adiciona dados aos buffers circulares\;
		buffer\_tempo.adicionar(tempo\_atual)\;
		buffer\_velocidade.adicionar(dados\_sensores["velocidade"])\;
		buffer\_acelerador.adicionar(dados\_sensores["acelerador"])\;
		buffer\_freio.adicionar(dados\_sensores["freio"])\;
		buffer\_g\_lateral.adicionar(dados\_sensores["g\_lateral"])\;
		buffer\_g\_frontal.adicionar(dados\_sensores["g\_frontal"])\;
		// Ajusta janela de visualização (últimos 30 segundos)\;
		x\_min $\leftarrow$ maximo(0, tempo\_atual - JANELA\_TEMPO)\;
		x\_max $\leftarrow$ tempo\_atual + 1\;
		// Atualiza linhas dos gráficos\;
		linha\_velocidade.atualizar(buffer\_tempo, buffer\_velocidade)\;
		linha\_acelerador.atualizar(buffer\_tempo, buffer\_acelerador)\;
		linha\_freio.atualizar(buffer\_tempo, buffer\_freio)\;
		linha\_g\_lateral.atualizar(buffer\_tempo, buffer\_g\_lateral)\;
		linha\_g\_frontal.atualizar(buffer\_tempo, buffer\_g\_frontal)\;
		// Redesenha canvas\;
		canvas.redesenhar()\;
	}
\end{algorithm}

\subsection{Sistema de Auto-Save e Exportação de Dados}
\label{subsec:autosave-cliente}

O sistema implementa salvamento automático periódico para garantir a preservação dos dados coletados durante as sessões de operação. A cada 20 segundos, o sistema verifica se há quantidade suficiente de dados novos e, em caso positivo, exporta logs, dados de sensores e telemetria para arquivos no diretório \texttt{exports/auto/}. O formato Pickle (binário nativo do Python) foi escolhido por oferecer performance 5 a 10 vezes superior ao CSV para \gls{serializacao} de estruturas de dados complexas. Após cada salvamento, os buffers são limpos para evitar duplicação de dados em exportações subsequentes. O \autoref{alg:auto-save} apresenta a lógica de verificação e salvamento.

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:auto-save}Auto-save periódico de dados}
	\Entrada{console, intervalo\_ms}
	\Saida{arquivos\_salvos}
	\Inicio{
		MIN\_LOGS $\leftarrow$ 100\;
		MIN\_SENSORES $\leftarrow$ 1000\;
		MIN\_TELEMETRIA $\leftarrow$ 100\;
		DIRETORIO $\leftarrow$ "exports/auto/"\;
		// Verifica se há dados novos suficientes\;
		qtd\_logs $\leftarrow$ contar\_linhas(console.log\_text)\;
		qtd\_sensores $\leftarrow$ tamanho(sensor\_display.historico)\;
		qtd\_telemetria $\leftarrow$ tamanho(telemetria.buffer\_tempo)\;
		// Só salva se atingir mínimo E houver dados novos\;
		\Se{(qtd\_logs $\geq$ MIN\_LOGS) OU (qtd\_sensores $\geq$ MIN\_SENSORES) OU (qtd\_telemetria $\geq$ MIN\_TELEMETRIA)}{
			timestamp $\leftarrow$ formato\_data("YYYYMMDD\_HHMMSS")\;
			// Salva logs em texto\;
			\Se{qtd\_logs $\geq$ MIN\_LOGS}{
				salvar\_arquivo(DIRETORIO + "logs\_" + timestamp + ".txt", console.log\_text)\;
			}
			// Salva sensores em Pickle (binário)\;
			\Se{qtd\_sensores $\geq$ MIN\_SENSORES}{
				pickle.salvar(DIRETORIO + "sensors\_" + timestamp + ".pkl", sensor\_display.historico)\;
			}
			// Salva telemetria em Pickle\;
			\Se{qtd\_telemetria $\geq$ MIN\_TELEMETRIA}{
				pickle.salvar(DIRETORIO + "telemetry\_" + timestamp + ".pkl", telemetria.dados)\;
			}
			// Limpa buffers após salvar\;
			console.log\_text.limpar()\;
			sensor\_display.resetar()\;
			telemetria.resetar()\;
		}
		// Reagenda próximo auto-save\;
		agendar(intervalo\_ms, auto\_save)\;
	}
\end{algorithm}

\section{Armazenamento de Logs e Validação}
\label{sec:logs-validacao}

O sistema de armazenamento de dados implementa salvamento automático periódico para garantir a preservação de informações de telemetria durante as sessões de operação. Os dados armazenados permitem validação das telemetrias entre corridas e análise posterior, de forma similar às equipes de Fórmula 1 que utilizam dados de sessões para otimização de desempenho.

\subsection{Formatos de Armazenamento}
\label{subsec:formatos-armazenamento}

A seleção dos formatos de armazenamento considerou velocidade de serialização, tamanho dos arquivos e facilidade de processamento posterior. A \autoref{tab:formatos-armazenamento} apresenta os formatos utilizados para cada tipo de dado.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:formatos-armazenamento} Formatos de armazenamento utilizados no sistema de auto-save}
\IBGEtab{}{%
	\begin{tabular}{p{3cm}p{2.5cm}p{4cm}p{5cm}}
		\toprule
		Tipo de Dado & Formato & Nomenclatura & Justificativa \\
		\midrule \midrule
		Logs do console & Texto (.txt) & \texttt{logs\_YYYYMMDD\_HHMMSS.txt} & Legibilidade humana, facilidade de inspeção \\
		\midrule
		Sensores brutos & Pickle (.pkl) & \texttt{sensors\_YYYYMMDD\_HHMMSS.pkl} & Serialização binária eficiente \\
		\midrule
		Telemetria & Pickle (.pkl) & \texttt{telemetry\_YYYYMMDD\_HHMMSS.pkl} & Preservação de estruturas Python complexas \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

O formato Pickle foi escolhido para dados numéricos por oferecer serialização binária nativa do Python, preservando estruturas complexas contendo listas e dicionários aninhados. Embora o Pickle não seja legível por humanos, a análise dos dados é realizada através de scripts Python que reconstroem as estruturas originais. Os arquivos de log mantêm formato texto para permitir inspeção manual rápida durante depuração.

\subsection{Estrutura dos Dados Armazenados}
\label{subsec:estrutura-dados-armazenados}

Os arquivos de sensores contêm dicionários Python com listas de valores para cada canal do sensor BMI160 e do sistema de monitoramento de energia: \texttt{timestamp}, \texttt{bmi160\_accel\_x}, \texttt{bmi160\_accel\_y}, \texttt{bmi160\_accel\_z}, \texttt{bmi160\_gyro\_x}, \texttt{bmi160\_gyro\_y}, \texttt{bmi160\_gyro\_z}, \texttt{g\_force\_lateral}, \texttt{g\_force\_frontal}, \texttt{current\_motor}, \texttt{current\_servos}, \texttt{current\_rpi}, \texttt{power\_total} e \texttt{voltage\_rpi}. Cada lista contém valores correspondentes ao mesmo índice temporal, permitindo correlação entre diferentes grandezas.

Os arquivos de telemetria armazenam dados processados para os gráficos da interface: \texttt{time}, \texttt{speed}, \texttt{throttle}, \texttt{brake}, \texttt{g\_lateral}, \texttt{g\_frontal} e metadados como \texttt{start\_time}, \texttt{points\_count} e \texttt{export\_time}. Esses dados representam valores já filtrados e normalizados, prontos para visualização.

\subsection{Script de Análise de Sessões}
\label{subsec:script-analise-sessoes}

O script \texttt{analyze\_session.py} foi desenvolvido para processar os arquivos gerados pelo sistema de auto-save, oferecendo análise estatística e visualização gráfica das sessões de operação. O script suporta três modos de operação: análise combinada de todos os arquivos do diretório (padrão), análise apenas dos arquivos mais recentes e análise de timestamp específico.

O processamento combina múltiplos arquivos Pickle em estruturas unificadas, concatenando as listas de cada canal para formar séries temporais contínuas. As estatísticas calculadas incluem duração total da sessão, velocidade máxima, média e mínima, tempo em aceleração total (\textit{full throttle}), tempo em frenagem, forças G laterais e frontais máximas, acelerações e velocidades angulares extremas, e consumo de energia quando disponível.

A visualização gráfica utiliza a biblioteca Matplotlib com estilo visual inspirado nas telemetrias de Fórmula 1, apresentando gráficos de velocidade ao longo do tempo, utilização de pedais, forças G, distribuição de velocidade em histograma e diagrama G-G (\textit{scatter plot} de força lateral versus frontal). A análise de logs identifica padrões de erros, avisos, conexões e desconexões através de expressões regulares.

O script também suporta exportação de relatório HTML formatado contendo todas as estatísticas e metadados da sessão, facilitando documentação e compartilhamento dos resultados experimentais. A \autoref{alg:analise-sessao} apresenta o fluxo principal do processamento.

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:analise-sessao}Análise de sessão de telemetria}
	\Entrada{diretório de dados, modo de operação}
	\Saida{estatísticas, gráficos, relatório}
	\Inicio{
		// Localiza arquivos por padrão de nomenclatura\;
		arquivos\_telemetria $\leftarrow$ glob("telemetry\_*.pkl")\;
		arquivos\_sensores $\leftarrow$ glob("sensors\_*.pkl")\;
		arquivos\_logs $\leftarrow$ glob("logs\_*.txt")\;
		// Carrega e combina dados de múltiplos arquivos\;
		dados\_combinados $\leftarrow$ dicionário vazio\;
		\Para{cada arquivo em arquivos\_telemetria}{
			dados $\leftarrow$ pickle.load(arquivo)\;
			\Para{cada chave, valores em dados}{
				dados\_combinados[chave].estender(valores)\;
			}
		}
		// Calcula estatísticas com NumPy\;
		velocidade $\leftarrow$ array(dados\_combinados["speed"])\;
		estatisticas.velocidade\_max $\leftarrow$ max(velocidade)\;
		estatisticas.velocidade\_media $\leftarrow$ media(velocidade)\;
		// Gera gráficos estilo F1\;
		plotar\_telemetria(dados\_combinados)\;
		plotar\_sensores(dados\_sensores)\;
		// Exporta relatório HTML\;
		exportar\_html(estatisticas, analise\_logs)\;
	}
\end{algorithm}

A leitura dos arquivos Pickle para análise externa pode ser realizada através do seguinte código Python:

\begin{verbatim}
import pickle
with open("sensors_20241216_143000.pkl", "rb") as f:
    dados = pickle.load(f)
# dados contém dicionário com listas de cada sensor
print(dados.keys())  # ['timestamp', 'bmi160_accel_x', ...]
print(len(dados['timestamp']))  # Quantidade de amostras
\end{verbatim}

\subsection{Métricas de Validação Extraídas}
\label{subsec:metricas-validacao}

Os dados armazenados pelo sistema de auto-save permitem a extração de métricas específicas para validação do desempenho do sistema. A \autoref{tab:metricas-validacao} apresenta as métricas extraídas de cada categoria de dados, organizadas por subsistema avaliado.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:metricas-validacao} Métricas de validação extraídas dos dados armazenados}
\IBGEtab{}{%
	\begin{tabular}{p{3cm}p{4cm}p{4cm}p{4cm}}
		\toprule
		Subsistema & Métrica & Fonte de Dados & Cálculo \\
		\midrule \midrule
		\multirow{3}{*}{Comunicação} & Latência média & \texttt{timestamp} & Diferença entre envio e recepção \\
		& \Gls{jitter} & \texttt{timestamp} & Desvio padrão dos intervalos \\
		& Packet loss & \texttt{logs\_*.txt} & Contagem de erros de recepção \\
		\midrule
		\multirow{3}{*}{Vídeo} & FPS efetivo & \texttt{telemetry\_*.pkl} & Frames por segundo médio \\
		& Estabilidade & \texttt{telemetry\_*.pkl} & Variância do intervalo entre frames \\
		& Throughput & \texttt{sensors\_*.pkl} & Bytes por segundo \\
		\midrule
		\multirow{3}{*}{Sensores} & Taxa de amostragem & \texttt{sensors\_*.pkl} & Amostras por segundo \\
		& \Gls{drifttermico} & \texttt{temperature} & Variação ao longo do tempo \\
		& Ruído & \texttt{bmi160\_accel\_*} & Desvio padrão em repouso \\
		\midrule
		\multirow{3}{*}{Force Feedback} & Tempo de resposta & \texttt{timestamp} & Latência comando-atuação \\
		& Precisão & \texttt{g\_force\_*} & Correlação sensor-feedback \\
		& Estabilidade & \texttt{gyro\_z} & Variância em regime permanente \\
		\midrule
		\multirow{2}{*}{Energia} & Consumo médio & \texttt{power\_total} & Média de potência \\
		& Pico de corrente & \texttt{current\_motor} & Valor máximo registrado \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

O script \texttt{analyze\_session.py} calcula automaticamente as estatísticas principais a partir dos dados armazenados. Para métricas de comunicação, o intervalo entre timestamps consecutivos permite estimar a latência efetiva do sistema, enquanto o desvio padrão desses intervalos caracteriza o jitter. A análise de logs por expressões regulares identifica eventos de erro, permitindo cálculo da taxa de perda de pacotes.

Para validação estatística dos resultados, o volume de dados coletado pelo sistema de auto-save garante robustez. Considerando taxa de amostragem de 100Hz para sensores e sessões típicas de 15 minutos, cada sessão gera aproximadamente 90.000 pontos de telemetria. Esse volume supera significativamente o mínimo de 384 amostras requerido para população infinita com 95\% de confiança e margem de erro de 5\%, proporcionando poder estatístico superior a 99\% para detectar diferenças com tamanho de efeito médio nas comparações com o estado da arte.

\section{Reprodutibilidade e Transparência Experimental}
\label{sec:reprodutibilidade-transparencia}

A garantia de reprodutibilidade científica constitui um pilar fundamental para a validação e evolução do conhecimento em engenharia de sistemas embarcados. Seguindo as diretrizes estabelecidas por \citeonline{graf2024monitoring} para avaliação de desempenho de sistemas wireless, este trabalho adota protocolos rigorosos de documentação e disponibilização de recursos para permitir a replicação completa dos experimentos realizados.

\subsection{Disponibilização de Código Fonte e Datasets}
\label{subsec:codigo-datasets}

Todo o código fonte desenvolvido para este projeto está disponibilizado publicamente no repositório GitHub sob licença MIT, acessível em \url{https://github.com/inacio-dev/tcc}. O repositório contém a estrutura completa do projeto, organizada conforme a \autoref{tab:estrutura-repositorio}.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:estrutura-repositorio} Estrutura do repositório de código fonte}
\IBGEtab{}{%
	\begin{tabular}{p{3.5cm}p{11cm}}
		\toprule
		Diretório & Conteúdo \\
		\midrule \midrule
		\texttt{raspberry/} & Scripts Python para controle do Raspberry Pi 4: captura de vídeo, leitura de sensores BMI160, controle de motor e servos, comunicação UDP \\
		\midrule
		\texttt{client/} & Interface gráfica em Python/Tkinter, recepção UDP, processamento de telemetria, sistema de auto-save e script de análise de sessões \\
		\midrule
		\texttt{esp32/} & Firmware C++ para ESP32: leitura de encoders, controle de force feedback, comunicação serial USB \\
		\midrule
		\texttt{exports/auto/} & Datasets de telemetria em formato Pickle (.pkl) e logs de sessões (.txt) \\
		\midrule
		\texttt{scripts/} & Rotinas de análise estatística e geração de gráficos \\
		\midrule
		\texttt{docs/} & Documentação técnica das decisões de projeto \\
		\midrule
		\texttt{monografia/} & Código fonte \LaTeX\ deste documento \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

Conforme demonstrado por \citeonline{bobrovsky2023development}, a transparência no desenvolvimento de sistemas embarcados facilita a reprodução e melhoria contínua das soluções propostas. Os datasets coletados durante as sessões experimentais, totalizando mais de 90.000 pontos de telemetria, estão disponíveis no diretório \texttt{exports/auto/} do repositório em formato Pickle, permitindo análise direta com o script \texttt{analyze\_session.py} incluso no projeto.

\subsection{Protocolo Detalhado de Replicação}
\label{subsec:protocolo-replicacao}

O protocolo de replicação experimental documentado contempla todos os aspectos críticos para reprodução fidedigna dos resultados obtidos. As especificações de hardware incluem números de modelo exatos, versões de firmware e configurações específicas de cada componente utilizado no sistema. Para o Raspberry Pi 4, documenta-se a versão do Raspberry Pi OS (Bullseye 64-bit), kernel utilizado (5.15.84-v8+) e configurações específicas do arquivo config.txt para otimização da câmera OV5647.

As configurações de rede wireless seguem padrões reproduzíveis, especificando canal WiFi (2.4GHz canal 6), potência de transmissão (20dBm), tipo de roteador utilizado (TP-Link Archer C6) e posicionamento físico dos equipamentos. As condições ambientais durante os experimentos são registradas detalhadamente, incluindo temperatura ambiente (22±2°C), umidade relativa (45±5\%), interferências eletromagnéticas medidas e layout físico do ambiente de teste.

\subsection{Documentação de Configurações Ambientais}
\label{subsec:configuracoes-ambientais}

As configurações ambientais experimentais são registradas sistematicamente para garantir reprodutibilidade das condições de teste. O ambiente de rede é caracterizado através de medições de potência de sinal WiFi utilizando ferramentas como iwconfig e wavemon, documentando valores de \gls{RSSI} em múltiplos pontos do ambiente experimental.

As características do ambiente físico incluem dimensões precisas do local de teste (5m × 8m), materiais de construção das paredes (alvenaria com reboco), presença de obstáculos metálicos e fontes potenciais de interferência eletromagnética. O posicionamento relativo entre veículo teleoperado e estação de controle é documentado com coordenadas precisas, utilizando sistema de referência baseado em marcos físicos permanentes.

As condições de iluminação para os testes de câmera são padronizadas utilizando iluminação artificial controlada (lâmpadas LED 6500K, 1000 lúmens), minimizando variações devido à iluminação natural. Os padrões de teste visual incluem alvos de calibração com dimensões conhecidas, permitindo validação da qualidade de captura de vídeo independente das condições específicas do ambiente.

O controle de temperatura ambiente utiliza sistema de climatização para manter estabilidade térmica durante as sessões experimentais, evitando drift térmico excessivo nos sensores. Registros contínuos de temperatura e umidade são mantidos através de datalogger dedicado, correlacionando variações ambientais com performance do sistema.
