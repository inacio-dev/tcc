\chapter{Metodologia}
\label{chap:metodologia}

Será realizado um desenvolvimento incremental e modular de um sistema completo de teleoperação de um veículo de Fórmula 1 com simulador (volante e pedais), sendo o veículo controlado via protocolo UDP. Utilizarei uma metodologia de prototipagem evolutiva, que busca o teste individual de cada componente antes da integração final. O projeto busca um objetivo semelhante ao artigo de \citeonline{shaik2025design}, conforme apresentado na fundamentação teórica.

O projeto seguirá uma arquitetura de três camadas. A primeira corresponde ao veículo teleoperado, tendo como elemento principal o Raspberry Pi 4, responsável por receber mensagens de controle via UDP e enviar mensagens de vídeo e status de sensores. A segunda camada é o cliente (notebook ou PC), que receberá as mensagens do veículo, exibirá a interface de telemetria e encaminhará as mensagens de controle oriundas do simulador para o veículo. A terceira camada é o simulador baseado em ESP32, composto por volante com encoder rotativo, pedais de acelerador e freio, e botões de troca de marcha, responsável por capturar os comandos do usuário e transmiti-los ao cliente via comunicação serial USB. A integração de múltiplos sensores segue a abordagem de \citeonline{bobrovsky2023development}, visando um bom resultado de feedback ao usuário. A \autoref{fig:arquitetura-projeto} apresenta o diagrama da arquitetura proposta.

As etapas de desenvolvimento seguem respectivamente:

\begin{alineascomnumero}
	\item Modelagem, impressão e montagem do chassi do veículo teleoperado;
	\item Testes de desempenho e comunicação entre o Raspberry Pi e o Cliente (PC);
	\item Integração gradual dos sensores e atuadores do veículo teleoperado com o Raspberry Pi;
	\item Testes de comunicação do veículo teleoperado completo com o PC\@;
	\item Modelagem, impressão e montagem do simulador (volante e pedais);
	\item Teste de atuadores e sensores de comando da direção e pedais para o PC via serial;
	\item Integração gradual do simulador com o PC via serial;
	\item Teste completo entre o veículo teleoperado e o simulador.
\end{alineascomnumero}

\begin{figure}[!h]
	\captionsetup{width=16cm}
	\Caption{\label{fig:arquitetura-projeto} Arquitetura do sistema de teleoperação com feedback háptico}
	\UFCfig{}{
		\includegraphics[width=16cm]{figuras/Arquitetura do Projeto}
	}{
		\Fonte{elaborado pelo autor.}
	}
\end{figure}

\section{Protocolo de Comunicação UDP}
\label{sec:protocolo-udp}

O UDP é um protocolo que lida com o alto envio de mensagens, muito utilizado para envio de streams e em jogos de computador. A arquitetura atual necessita de baixa latência, pois uma latência muito alta irá atrapalhar o controle em tempo real do veículo teleoperado, passando por um alto delay de comandos e prejudicando a experiência do usuário. Conforme demonstrado por \citeonline{lu2023udprt} na fundamentação teórica, protocolos baseados em UDP alcançam latências significativamente inferiores ao TCP em aplicações de tempo real, justificando o uso desse protocolo.

\subsection{Evolução das Decisões de Arquitetura de Comunicação}
\label{subsec:evolucao-decisoes-comunicacao}

A arquitetura final de comunicação do sistema foi definida após uma série de testes experimentais com diferentes tecnologias e topologias de rede. O objetivo inicial era verificar a viabilidade de controlar múltiplos veículos simultaneamente através de um servidor central que redirecionaria mensagens entre clientes e veículos. A meta de latência estabelecida foi de no máximo 10ms para comunicação em tempo real na mesma rede local.

\subsubsection{Testes com Arduino Mega e ESP8266}

A primeira configuração testada utilizou um Arduino Mega com módulo ESP8266 como controlador do veículo, comunicando-se via WiFi com um Raspberry Pi 4 (servidor) e um notebook (cliente). Os resultados demonstraram latência média de 60ms, valor considerado inadequado para controle em tempo real. A análise identificou o módulo ESP8266 como gargalo do sistema: mesmo com o Raspberry Pi enviando mensagens a cada 1ms, o ESP8266 não conseguia processar adequadamente devido à necessidade de alternar entre modos de leitura e escrita para processar e transmitir mensagens.

\subsubsection{Testes com ESP32}

Para melhorar o processamento, o Arduino Mega com ESP8266 foi substituído por um ESP32 DevKit V1, que possui processador dual-core mais potente apesar de menor quantidade de pinos GPIO. A latência reduziu para 40ms, representando melhoria de 33\% em relação à configuração anterior. Entretanto, esse valor ainda não atendia à meta de 10ms, considerando que a comunicação UDP entre servidor e cliente adicionaria latência adicional em cenários com servidores geograficamente distribuídos.

\subsubsection{Testes com Módulo NRF24L01}

Buscando comunicação mais rápida entre servidor e veículo, foram realizados testes com módulos de rádio NRF24L01 com antena externa, capazes de alcançar até 800 metros com boa qualidade de sinal. Os resultados foram expressivos: latência de apenas 2ms entre os dispositivos. Porém, essa abordagem implica comunicação direta ponto-a-ponto entre servidor e veículo, aumentando a complexidade para adicionar novos veículos ao sistema.

\subsubsection{Avaliação de Redes Mesh}

Para estender o alcance além dos 800 metros do NRF24L01, foi avaliada a implementação de rede mesh. A análise indicou acréscimo de aproximadamente 2ms de latência para cada salto entre antenas intermediárias, além de introduzir erros na resposta de status do veículo. Uma otimização testada foi utilizar o payload de ACK (\textit{acknowledgment}) para retorno de status dos sensores. O ACK é uma confirmação de recebimento que o NRF24L01 envia automaticamente ao transmissor; ao anexar dados do sensor nessa confirmação, elimina-se a necessidade de alternar o módulo entre modos de transmissão e recepção, reduzindo latência. Contudo, essa abordagem tornou a implementação de mesh com NRF24L01 excessivamente complexa para o cronograma disponível.

O protocolo ESP-NOW foi considerado como alternativa para comunicação mesh entre dispositivos ESP32, porém foi descartado devido ao alcance limitado de aproximadamente 50 metros, significativamente inferior aos 800 metros do NRF24L01 com antena externa, além do custo mais elevado por unidade.

\subsubsection{Decisão Final: Arquitetura UDP com Raspberry Pi e ESP32}

A análise comparativa dos testes, sumarizada na \autoref{tab:comparativo-comunicacao}, conduziu à definição da arquitetura final baseada em três pilares: protocolo UDP, Raspberry Pi 4 embarcado no veículo e ESP32 no simulador. O princípio norteador foi manter o sistema simples e funcional.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:comparativo-comunicacao} Comparativo de latência entre tecnologias de comunicação testadas}
\IBGEtab{}{%
	\begin{tabular}{p{5cm}p{3cm}p{3cm}p{4cm}}
		\toprule
		Configuração & Latência Média & Alcance & Observações \\
		\midrule \midrule
		Arduino Mega + ESP8266 & 60ms & WiFi local & Gargalo no ESP8266 \\
		\midrule
		ESP32 DevKit V1 & 40ms & WiFi local & Melhoria de 33\% \\
		\midrule
		NRF24L01 + antena & 2ms & 800m & Comunicação ponto-a-ponto \\
		\midrule
		NRF24L01 mesh & 2ms + 2ms/salto & Extensível & Complexidade elevada \\
		\midrule
		ESP-NOW (ESP32) & Similar ao WiFi & 50m & Custo elevado, alcance limitado \\
		\midrule
		\textbf{RPi 4 embarcado + UDP} & \textbf{1ms} & \textbf{WiFi local} & \textbf{Solução adotada} \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

A comunicação via rádio NRF24L01, apesar de apresentar excelente latência (2ms) e alcance (800m), exigiria a implementação de um broker intermediário para traduzir os pacotes de rádio para o protocolo UDP do servidor. Essa camada adicional aumentaria a complexidade do sistema, introduziria novos pontos de falha e demandaria desenvolvimento de firmware específico para gerenciamento da comunicação bidirecional entre rádio e rede IP. Além disso, embora o NRF24L01 seja adequado para transmissão de comandos de controle (pacotes pequenos de dezenas de bytes), a transmissão de vídeo em tempo real seria inviável: o módulo opera com taxa máxima de 2 Mbps e payload limitado a 32 bytes por pacote, tornando a fragmentação e remontagem de frames MJPEG (10 a 50 KB cada) excessivamente complexa e propensa a erros. Implementar um protocolo confiável de transmissão de imagem sobre rádio demandaria esforço de desenvolvimento incompatível com o cronograma do projeto.

A decisão de embarcar o Raspberry Pi 4 diretamente no veículo eliminou essas limitações, permitindo comunicação UDP nativa sobre WiFi. Com o Raspberry Pi embarcado, a captura de vídeo, codificação MJPEG e transmissão UDP ocorrem internamente no mesmo dispositivo, simplificando drasticamente a arquitetura. O Raspberry Pi atua simultaneamente como controlador do veículo e servidor UDP, processando vídeo da câmera OV5647, dados do sensor BMI160 e comandos de controle em uma única plataforma.

A arquitetura de comunicação utiliza três portas UDP separadas para otimizar o desempenho de cada tipo de dado, conforme detalhado na \autoref{tab:arquitetura-portas-udp}. Essa separação é necessária porque pacotes de vídeo grandes (50 KB) bloqueariam os pacotes pequenos de sensores (200 bytes) se compartilhassem a mesma porta, e o sistema de force feedback requer taxa consistente de 100Hz com latência inferior a 10ms para resposta tátil adequada no volante.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:arquitetura-portas-udp} Arquitetura de comunicação UDP com três portas separadas}
\IBGEtab{}{%
	\begin{tabular}{ccp{5cm}ccc}
		\toprule
		Porta & Direção & Conteúdo & Taxa & Pacote & Buffer \\
		\midrule \midrule
		9999 & RPi $\rightarrow$ PC & Vídeo MJPEG + energia + temperatura & 30Hz & 10--50 KB & 64 KB \\
		\midrule
		9997 & RPi $\rightarrow$ PC & Sensores BMI160 (aceleração e giroscópio) & 100Hz & 200 B & 8 KB \\
		\midrule
		9998 & Bidirecional & Comandos de controle (acelerador, freio, direção, marcha) & On-demand & 50 B & 8 KB \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

Para o simulador, o ESP32 DevKit V1 foi mantido devido ao seu processamento superior em relação ao Arduino Mega, com dual-core de 240MHz contra single-core de 16MHz. O firmware opera com taxa de atualização de 100Hz (intervalo de 10ms entre transmissões), permitindo leitura simultânea de três encoders rotacionais, processamento de comandos de force feedback e comunicação serial USB a 115200 baud com o cliente PC sem perda de dados. O processamento é distribuído entre os dois núcleos: o Core 0 executa a leitura de encoders e controle do motor de force feedback com alta prioridade, enquanto o Core 1 gerencia a comunicação serial. A comunicação serial USB entre ESP32 e cliente elimina a necessidade de protocolos wireless adicionais no simulador, garantindo conexão estável e determinística.

Essa arquitetura resultou em um sistema com apenas dois saltos de comunicação (Veículo $\leftrightarrow$ Cliente $\leftrightarrow$ Simulador), maximizando a confiabilidade e minimizando a latência total do loop de controle.

\subsection{Justificativa para UDP Simples}
\label{subsec:justificativa-udp}

A escolha do UDP simples sobre protocolos mais avançados como UDP-RT \citeonline{lu2023udprt} é justificada pela necessidade de simplicidade de implementação e recursos limitados do Raspberry Pi 4. Embora o UDP-RT ofereça vantagens em redes congestionadas, sua implementação requer mecanismos adicionais de correção de erros e detecção na camada de aplicação, aumentando significativamente a complexidade do sistema. Conforme demonstrado nos resultados, a latência obtida de 1,94ms com UDP simples supera os targets típicos de 5ms, validando que esta abordagem é adequada para o projeto.

\subsection{Limitações de Alcance e Considerações de Escala}
\label{subsec:limitacoes-alcance}

O alcance da comunicação WiFi constitui uma limitação relevante para operação do veículo em pistas de maior extensão. Considerando que o veículo foi construído na escala 1:5 e que circuitos de Fórmula 1 reais possuem extensões entre 3 km (Mônaco) e 7 km (Spa-Francorchamps), uma pista em escala correspondente teria entre 600 m e 1.400 m de comprimento.

A \autoref{tab:alcance-wifi-pistas} apresenta a análise de viabilidade de cobertura WiFi para pistas em escala 1:5, considerando as características de roteadores comerciais e possíveis extensões de alcance.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:alcance-wifi-pistas} Análise de cobertura WiFi para pistas de F1 em escala 1:5}
\IBGEtab{}{%
	\begin{tabular}{p{4cm}p{2.5cm}p{2.5cm}p{5.5cm}}
		\toprule
		Circuito Real & Extensão Real & Escala 1:5 & Solução de Cobertura \\
		\midrule \midrule
		Mônaco & 3,337 km & 667 m & Roteador central + 1 repetidor \\
		\midrule
		Interlagos & 4,309 km & 862 m & 2 access points mesh \\
		\midrule
		Silverstone & 5,891 km & 1.178 m & 3 access points mesh \\
		\midrule
		Spa-Francorchamps & 7,004 km & 1.401 m & 4 access points mesh ou 5G \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

Para pistas de até 600 m (equivalente a circuitos compactos como Mônaco), um roteador WiFi comercial de alta potência (20 dBm) posicionado centralmente oferece cobertura adequada em ambiente aberto. Para pistas maiores, a implementação de redes mesh com múltiplos access points permite extensão do alcance, adicionando aproximadamente 2 ms de latência por salto entre nós da rede. Alternativamente, redes 5G oferecem cobertura ampla com latência potencialmente inferior, porém com maior custo de infraestrutura e dependência de operadoras.

O projeto atual foi validado em ambiente de teste com dimensões de 40 m $\times$ 80 m, suficiente para circuitos de kart em escala 1:5. A extensão para pistas maiores requer planejamento de infraestrutura de rede conforme as dimensões do circuito desejado.

% ============================================================================
% ARQUITETURA DO VEÍCULO (RASPBERRY PI 4)
% ============================================================================
\section{Arquitetura do Veículo (Raspberry Pi 4)}
\label{sec:arquitetura-veiculo}

O Raspberry Pi 4 Model B com 8GB de RAM constitui o núcleo de processamento embarcado no veículo, responsável por todas as operações de controle, sensoriamento e comunicação. A escolha deste hardware foi motivada pela capacidade de processamento suficiente para codificação de vídeo MJPEG em tempo real, comunicação UDP nativa e controle de múltiplos periféricos via I2C, conforme validado nos testes de arquitetura descritos na \autoref{subsec:evolucao-decisoes-comunicacao}. O diagrama elétrico completo das conexões do Raspberry Pi 4 com todos os componentes do sistema está disponível no \autoref{apendice:diagrama-rpi}.

O software embarcado foi desenvolvido em Python 3.11.2 utilizando o editor Visual Studio Code, aproveitando bibliotecas nativas para controle de GPIO, comunicação I2C e captura de vídeo via interface CSI. A \autoref{tab:bibliotecas-rpi} apresenta as principais bibliotecas utilizadas no desenvolvimento do software embarcado.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:bibliotecas-rpi} Bibliotecas Python utilizadas no Raspberry Pi}
\IBGEtab{}{
\begin{tabular}{p{4.5cm}p{10cm}}
\toprule
\textbf{Biblioteca} & \textbf{Função} \\
\midrule
picamera2 & Captura de vídeo via interface CSI com codificação MJPEG por hardware \\
smbus2 & Comunicação I2C direta com sensores BMI160, ADS1115 e INA219 \\
adafruit-circuitpython-pca9685 & Controle do driver PWM PCA9685 para acionamento de servos \\
adafruit-circuitpython-servokit & Abstração de alto nível para controle de servomotores \\
RPi.GPIO & Controle de pinos GPIO para ponte H BTS7960 do motor DC \\
numpy & Processamento numérico de dados de sensores e cálculos de telemetria \\
socket & Comunicação UDP nativa para transmissão de dados ao cliente \\
\bottomrule
\end{tabular}
}{
\Fonte{elaborado pelo autor.}
}
\end{table}

\subsection{Especificações dos Componentes do Veículo}
\label{subsec:componentes-veiculo}

A \autoref{tab:componentes-veiculo} apresenta os componentes embarcados no veículo teleoperado, responsáveis pelo controle de propulsão, sensoriamento e comunicação via UDP.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:componentes-veiculo} Especificações dos componentes do veículo teleoperado}
\IBGEtab{}{%
	\begin{tabular}{p{3.5cm}p{6cm}p{6cm}}
		\toprule
		Componente & Especificação & Função no Sistema \\
		\midrule \midrule
		Raspberry Pi 4 Model B & Broadcom BCM2711, Quad core Cortex-A72 64-bit @ 1.8GHz, 8GB RAM & Núcleo de controle e comunicação do veículo, servidor UDP, processamento de vídeo e controle de sensores \\
		\midrule
		Câmera OV5647 & 5MP, 2592×1944 pixels, vídeo 1080p/30fps, interface CSI & Captura de vídeo em tempo real para transmissão via UDP \\
		\midrule
		Sensor BMI160 \cite{bosch2015bmi160} & IMU 6 eixos, ±4g/±500°/s, 16 bits, I2C, 100Hz sampling & Detecção de forças G, aceleração e velocidade angular para force feedback \\
		\midrule
		Motor RC 775 & 24V, 12.000 RPM, com transmissão manual de 5 marchas & Propulsão principal do veículo com zonas de eficiência F1 \\
		\midrule
		Ponte H BTS7960 \cite{infineon2013btn7960} & 5.5--27Vdc, corrente contínua 40A, proteção térmica integrada & Controle bidirecional de velocidade do motor de propulsão \\
		\midrule
		Servo MG996R (3x) & 4.8--7.2V, torque 11kg.cm, rotação 180°, velocidade 0.14s/60° & Controle de direção e sistema de freio dianteiro/traseiro \\
		\midrule
		PCA9685 PWM Driver \cite{nxp2015pca9685} & 16 canais, 12 bits, I2C, endereço \texttt{0x40} & Controle de servos (freio dianteiro, traseiro e direção) \\
		\midrule
		ADS1115 ADC \cite{ti2018ads1115} & 16 bits, 4 canais, I2C, endereço \texttt{0x48} & Monitoramento de corrente via sensores ACS758 \\
		\midrule
		INA219 \cite{ti2015ina219} & Sensor corrente/tensão, I2C, endereço \texttt{0x41} & Monitoramento de energia do Raspberry Pi \\
		\midrule
		Sensor DS18B20 \cite{maxim2019ds18b20} & Digital 1-Wire, $-55$°C a $+125$°C, precisão $\pm0{,}5$°C & Monitoramento de temperatura do motor e eletrônica \\
		\midrule
		ACS758 100A \cite{allegro2018acs758} & Sensor Hall, sensibilidade 20mV/A, largura de banda 120kHz & Medição de corrente do motor DC 775 via ADS1115 \\
		\midrule
		ACS758 50A (2x) \cite{allegro2018acs758} & Sensor Hall, sensibilidade 40mV/A, largura de banda 120kHz & Medição de corrente do Raspberry Pi e servos via ADS1115 \\
		\midrule
		Regulador XL4015 \cite{xlsemi2017xl4015} & Step-down 8--36V para 1.25--32V, 5A, eficiência 96\% & Alimentação 5V do Raspberry Pi a partir da bateria \\
		\midrule
		UBEC 15A & 6--12S entrada, 5.25V saída, 15A contínuo, 30A pico & Alimentação dos servos MG996R \\
		\midrule
		Bateria LiPo 3S & Turnigy Graphene 6000mAh, 11.1V, 75C descarga & Fonte de energia principal do veículo \\
		\midrule
		Caixa Diferencial HSP 1:10 & Modelo 94111/94123, relação 02051 & Transmissão diferencial para rodas traseiras \\
		\midrule
		Rolamento Unidirecional CSK8PP & $8\times22\times9$mm, uma direção de rotação & Proteção contra torque reverso no eixo do motor de propulsão \\
		\midrule
		Amortecedores RC 1:10 & Compatível Axial SCX10/TRX4, óleo ajustável & Suspensão do veículo com amortecimento ajustável \\
		\midrule
		Chassi FV01 & Escala 1:5 (modificada), impressão 3D em PLA, pneus de borracha & Estrutura do veículo com suspensão push rod e aerodinâmica funcional \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

\subsection{Chassi e Estrutura}
\label{subsec:chassi-estrutura-veiculo}

O veículo utiliza o chassi FV01, um modelo de carro de Fórmula 1 projetado para impressão 3D por \citeonline{velocityprojects2024fv01}. O modelo original possui escala 1:7, porém foi modificado para escala 1:5 neste projeto para acomodar o Raspberry Pi 4, sensores, drivers e demais componentes eletrônicos. O chassi foi impresso em PLA com pneus de borracha para melhor aderência.

O modelo apresenta características que o tornam adequado para teleoperação com feedback háptico. A suspensão push rod independente reproduz o comportamento de carros de F1 reais, permitindo detecção precisa de forças G pelo sensor BMI160. O diferencial operacional proporciona comportamento realista em curvas, enquanto a modularidade do projeto facilita manutenção e substituição de peças.

A impressão das peças do chassi foi realizada utilizando o software fatiador Ultimaker Cura 5.11 \cite{ultimaker2024cura} com perfil de qualidade padrão. A \autoref{tab:config-impressao-3d} apresenta os principais parâmetros de impressão utilizados, selecionados para balancear resistência mecânica, tempo de impressão e consumo de material.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:config-impressao-3d} Parâmetros de impressão 3D do chassi FV01}
\IBGEtab{}{%
	\begin{tabular}{p{5cm}p{4cm}p{6cm}}
		\toprule
		Parâmetro & Valor & Observação \\
		\midrule \midrule
		Altura de camada & 0,2 mm & Qualidade padrão \\
		\midrule
		Espessura de parede & 0,8 mm & 2 linhas de parede \\
		\midrule
		Densidade de preenchimento & 15\% & Padrão Cubic Subdivision \\
		\midrule
		Temperatura de impressão & 210°C & 215°C na camada inicial \\
		\midrule
		Temperatura da mesa & 60°C & --- \\
		\midrule
		Velocidade de impressão & 60 mm/s & 25 mm/s na camada inicial \\
		\midrule
		Velocidade de deslocamento & 150 mm/s & --- \\
		\midrule
		Suporte & Tree & Ângulo de overhang 45° \\
		\midrule
		Adesão à mesa & Raft & Margem de 5 mm, 2 camadas \\
		\midrule
		Resfriamento & 100\% & Ventoinha ativada \\
		\midrule
		Retração & 0,8 mm & Velocidade de 40 mm/s \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

A densidade de preenchimento de 15\% com padrão Cubic Subdivision foi escolhida por oferecer boa resistência estrutural com economia de material, enquanto o suporte tipo Tree minimiza o contato com a superfície da peça, facilitando a remoção e melhorando o acabamento. O uso de Raft como adesão à mesa garante estabilidade durante a impressão de peças maiores, evitando empenamento nas bordas. A \autoref{fig:chassi-fv01} apresenta o modelo original do chassi FV01.

\begin{figure}[!ht]
	\captionsetup{width=16cm}
	\Caption{\label{fig:chassi-fv01} Modelo do chassi FV01 projetado para impressão 3D}
	\UFCfig{}{
		\includegraphics[width=12cm]{figuras/FV01-1}
	}{
		\Fonte{\citeonline{velocityprojects2024fv01}.}
	}
\end{figure}

Para realizar as modificações de escala e planejar a disposição interna dos componentes, utilizou-se o Tinkercad \cite{autodesk2024tinkercad}, uma ferramenta de modelagem 3D gratuita baseada em navegador. A \autoref{fig:tinkercad-layout} apresenta a simulação realizada, onde a bateria LiPo 3S (em vermelho) ocupa a região central inferior e o motor DC 775 com a transmissão (em laranja) está posicionado na parte traseira. Essa simulação prévia demonstrou que a escala 1:5 proporciona espaço adequado para os demais componentes eletrônicos.

\begin{figure}[!ht]
	\captionsetup{width=16cm}
	\Caption{\label{fig:tinkercad-layout} Simulação no Tinkercad da organização interna dos componentes no chassi FV01 modificado}
	\UFCfig{}{
		\includegraphics[width=14cm]{figuras/thinckercad}
	}{
		\Fonte{elaborado pelo autor.}
	}
\end{figure}

\subsection{Sistema de Sensoriamento}
\label{subsec:sensoriamento-veiculo}

O veículo incorpora múltiplos sensores para captura de dados em tempo real, transmitidos ao cliente via UDP para processamento e geração de feedback háptico.

\subsubsection{Câmera OV5647}

A câmera OV5647 conectada via interface CSI captura vídeo em resolução 640x480 a 30 FPS. O stream de vídeo é codificado em MJPEG (Motion JPEG), onde cada frame é comprimido independentemente como imagem JPEG. Essa escolha foi motivada pela robustez contra perda de pacotes UDP: enquanto codecs como H.264 utilizam P-frames que dependem de frames anteriores (causando distorção em cascata quando há perda de pacotes), o MJPEG transmite frames independentes, limitando o impacto de perdas a um único frame. O trade-off é maior uso de banda (aproximadamente 4x mais que H.264), compensado pela qualidade de imagem consistente e simplicidade de decodificação via OpenCV.

\subsubsection{Sensor IMU BMI160}

O sensor inercial BMI160 conectado via barramento I2C (endereço \texttt{0x68}) fornece dados de aceleração (3 eixos) e velocidade angular (3 eixos) a 100Hz. A configuração utiliza faixa de $\pm$4g para acelerômetro e $\pm$500°/s para giroscópio, adequadas para captura de forças G em manobras típicas de veículos RC. Os dados são transmitidos ao cliente em formato JSON via UDP, onde são processados para cálculo de force feedback e estimativa de velocidade.

\subsubsection{Monitoramento de Energia}

O sistema de monitoramento de energia utiliza sensores ACS758 (50A e 100A) conectados ao ADC ADS1115 (endereço \texttt{0x48}) para medição de corrente, e sensor INA219 (endereço \texttt{0x41}) para monitoramento de tensão e corrente do Raspberry Pi. Esses dados permitem análise de consumo energético e detecção de anomalias durante operação.

\subsection{Controle de Propulsão e Direção}
\label{subsec:propulsao-direcao-veiculo}

O sistema de propulsão utiliza motor RC 775 de 24V controlado por ponte H BTS7960, enquanto direção e freios são acionados por servos MG996R através do driver PWM PCA9685 (endereço \texttt{0x40}).

\subsubsection{Motor de Propulsão}

O motor RC 775 opera com transmissão manual de 5 marchas, simulando comportamento de veículo real. O controle de velocidade é realizado via PWM através do driver BTS7960. O sistema implementa zonas de eficiência inspiradas em veículos de Fórmula 1, onde cada marcha possui uma faixa ideal de operação em termos de PWM do motor. Operar fora dessa faixa resulta em penalização na taxa de aceleração, calculada conforme a equação:

\begin{equation}
\label{eq:taxa-aceleracao}
Taxa_{acel} = \frac{100\%}{T_{base}} \times M_{zona}
\end{equation}

\noindent onde $T_{base} = 5s$ é o tempo base para atingir 100\% do PWM, e $M_{zona}$ é o multiplicador da zona de eficiência: $M_{IDEAL} = 1.0$, $M_{SUB} = 0.1$ (10× mais lento), e $M_{RUIM} = 0.04$ (25× mais lento). Isso resulta em taxas de 20\%/s na zona IDEAL, 2\%/s na zona SUBÓTIMA e 0.8\%/s na zona RUIM, conforme ilustrado na \autoref{fig:taxa-aceleracao-zonas}.

\begin{figure}[!ht]
	\captionsetup{width=16cm}
	\Caption{\label{fig:taxa-aceleracao-zonas} Taxa de aceleração por zona de eficiência}
	\UFCfig{}{
		\includegraphics[width=12cm]{figuras/taxa_aceleracao_zonas}
	}{
		\Fonte{elaborado pelo autor.}
	}
\end{figure}

A \autoref{fig:zonas-eficiencia-marchas} ilustra as zonas de eficiência por marcha. Cada marcha possui uma zona IDEAL (verde) onde a aceleração ocorre em taxa normal, uma zona SUBÓTIMA (laranja) com aceleração 10 vezes mais lenta, e uma zona RUIM (vermelho) com aceleração 25 vezes mais lenta. Os limitadores de PWM restringem a potência máxima disponível em cada marcha: 15\% na 1ª, 30\% na 2ª, 60\% na 3ª, 90\% na 4ª e 100\% na 5ª marcha. As marchas 1ª e 2ª dividem a faixa de 0-30\% do PWM (marchas lentas), as marchas 3ª e 4ª dividem a faixa de 30-90\% (marchas médias e altas), enquanto a 5ª marcha possui zona IDEAL ampla de 70-100\% (velocidade pura). Esse sistema força o operador a progredir pelas marchas para atingir velocidade máxima, reproduzindo o comportamento de uma transmissão real.

\begin{figure}[!ht]
	\captionsetup{width=16cm}
	\Caption{\label{fig:zonas-eficiencia-marchas} Zonas de eficiência F1 por marcha}
	\UFCfig{}{
		\includegraphics[width=14cm]{figuras/zonas_eficiencia_marchas}
	}{
		\Fonte{elaborado pelo autor.}
	}
\end{figure}

\subsubsection{Sistema de Direção e Freios}

A direção utiliza servo MG996R no canal 2 do PCA9685, com rotação de 0° a 180°. O sistema de freio emprega dois servos MG996R (canais 0 e 1) para controle independente de freio dianteiro e traseiro, permitindo ajuste de balanceamento de frenagem. O balanceamento padrão é 60\% dianteiro e 40\% traseiro, ajustável via comandos do cliente.

\subsection{Proteção contra Força Eletromotriz de Retorno}
\label{subsec:protecao-backemf-veiculo}

Quando um motor DC gira, seja por acionamento elétrico ou por força mecânica externa, ele atua como gerador e produz uma tensão conhecida como força eletromotriz de retorno (\textit{back-EMF}). No contexto deste projeto, essa situação ocorre tanto no veículo (quando as rodas giram livremente com motor desligado) quanto no simulador (quando o operador gira o volante manualmente).

O driver BTS7960 foi selecionado para ambos os sistemas, veículo e simulador, especificamente por possuir proteções integradas contra esse fenômeno. Conforme especificado no datasheet do fabricante \citeonline{infineon2013btn7960}, o circuito integrado BTN7960 (chip utilizado no módulo BTS7960) incorpora capacidade de \textit{active freewheeling} com frequência PWM de até 25 kHz, minimizando a dissipação de potência nos diodos integrados quando o motor opera como gerador. Além disso, o BTN7960 oferece proteção contra sobrecorrente, proteção térmica com desligamento automático em temperaturas elevadas e proteção contra curto-circuito.

No veículo, uma proteção mecânica adicional foi implementada através de rolamento unidirecional no eixo de transmissão. Esse componente permite que as rodas girem livremente sem transmitir rotação reversa ao motor, reduzindo a geração de back-EMF quando o veículo está em movimento com motor desligado. No simulador, essa proteção mecânica não é aplicável porque o motor de force feedback necessita operar em ambas as direções para simular resistência no volante, dependendo exclusivamente das proteções eletrônicas do BTS7960.

Essa arquitetura de proteção elimina a necessidade de componentes externos adicionais, como diodos flyback ou capacitores de supressão de transientes, simplificando o projeto eletrônico e aumentando a confiabilidade do sistema.

% ============================================================================
% ARQUITETURA DO SIMULADOR (ESP32)
% ============================================================================
\section{Arquitetura do Simulador (ESP32)}
\label{sec:arquitetura-simulador}

O ESP32 DevKit V1 com processador dual-core Xtensa LX6 a 240MHz constitui o controlador do simulador, responsável pela leitura de encoders, controle do motor de force feedback e comunicação serial com o cliente PC. A escolha do ESP32 sobre o Arduino Mega foi motivada pelo processamento superior, conforme demonstrado nos testes de latência da \autoref{subsec:evolucao-decisoes-comunicacao}.

O firmware foi desenvolvido em C++ utilizando o Arduino IDE, aproveitando o framework Arduino para ESP32 que fornece abstrações para controle de GPIO, interrupções de hardware e comunicação serial. A \autoref{tab:bibliotecas-esp32} apresenta as bibliotecas utilizadas no desenvolvimento do firmware.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:bibliotecas-esp32} Bibliotecas C++ utilizadas no ESP32}
\IBGEtab{}{
\begin{tabular}{p{4cm}p{10.5cm}}
\toprule
\textbf{Biblioteca} & \textbf{Função} \\
\midrule
Arduino.h & Framework base com abstrações para GPIO, PWM e temporização \\
EEPROM.h & Armazenamento persistente de dados de calibração dos encoders \\
FreeRTOS & Sistema operacional de tempo real para execução dual-core \\
HardwareSerial & Comunicação serial USB com o cliente PC a 115200 baud \\
\bottomrule
\end{tabular}
}{
\Fonte{elaborado pelo autor.}
}
\end{table}

\subsection{Especificações dos Componentes do Simulador}
\label{subsec:componentes-simulador}

A \autoref{tab:componentes-simulador} apresenta os componentes do simulador de controle, responsáveis pela interface física com o operador e geração de feedback háptico.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:componentes-simulador} Especificações dos componentes do simulador de controle}
\IBGEtab{}{%
	\begin{tabular}{p{3.5cm}p{6cm}p{6cm}}
		\toprule
		Componente & Especificação & Função no Sistema \\
		\midrule \midrule
		ESP32 DevKit V1 \cite{espressif2024esp32} & Dual-core Xtensa LX6 @ 240MHz, 520KB SRAM, 4MB Flash, WiFi/Bluetooth & Controle de encoders, force feedback via BTS7960 e comunicação serial USB com cliente PC \\
		\midrule
		Encoder LPD3806-600BM (3x) & 600 PPR, saída A/B quadratura, 5--24V & Leitura de posição de acelerador, freio e direção \\
		\midrule
		Motor DC 775 & 24V, 12.000 RPM, controlado por BTS7960 & Geração de force feedback no volante \\
		\midrule
		Ponte H BTS7960 \cite{infineon2013btn7960} & 5.5--27Vdc, corrente contínua 40A, proteção térmica integrada & Controle bidirecional do motor de force feedback \\
		\midrule
		Atuadores Lineares DC & 12V, força 1000N, curso 250mm, velocidade 14mm/s & Simulação de movimentos da pista e força G \\
		\midrule
		Amortecedores RC 1:10 & Compatível Axial SCX10/TRX4, óleo ajustável & Amortecimento dos pedais de acelerador e freio \\
		\midrule
		Botões Push (2x) & Normalmente aberto, com resistor pull-up interno & Controle de troca de marchas (subir/descer) \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

O volante do simulador utiliza uma réplica em escala real do volante da McLaren MP4-30 de 2015, modelo 3D composto por 129 peças impressas em PLA, projetado por \citeonline{nacho3d2020volante}. A estrutura foi adaptada para acomodar o encoder rotacional de direção e o motor DC 775 de force feedback, mantendo a ergonomia e aparência característica dos volantes de Fórmula 1.

\subsection{Leitura de Encoders Rotacionais}
\label{subsec:encoders-simulador}

O simulador utiliza três encoders rotacionais LPD3806-600BM-G5-24C com resolução de 600 pulsos por revolução (PPR) e saída em quadratura (canais A e B). A leitura é realizada via interrupções de hardware nos pinos GPIO, garantindo captura precisa mesmo em rotações rápidas.

O encoder de acelerador utiliza GPIO 25 (CLK) e GPIO 26 (DT) com pinos invertidos para correção de direção. O encoder de freio utiliza GPIO 27 (CLK) e GPIO 14 (DT). O encoder de direção utiliza GPIO 12 (CLK) e GPIO 13 (DT), também com pinos invertidos para correção de direção.

Os valores dos encoders são normalizados para porcentagem (0--100\% para acelerador e freio) ou ângulo (-100\% a +100\% para direção) e transmitidos ao cliente a 100Hz via serial USB.

\subsection{Controle de Marchas}
\label{subsec:marchas-simulador}

O sistema de marchas utiliza dois botões push conectados aos GPIO 32 (subir marcha) e GPIO 33 (descer marcha). A detecção é feita por polling com debounce de software, evitando acionamentos múltiplos. Eventos de troca de marcha são transmitidos ao cliente como mensagens \texttt{GEAR\_UP} e \texttt{GEAR\_DOWN}. O \autoref{alg:debounce-marchas} apresenta o algoritmo de leitura com debounce implementado.

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:debounce-marchas}Leitura de botão com debounce}
	\Entrada{pino, estado\_anterior, tempo\_anterior}
	\Saida{pressionado}
	\Inicio{
		leitura $\leftarrow$ digitalRead(pino)\;
		pressionado $\leftarrow$ falso\;
		tempo\_atual $\leftarrow$ millis()\;
		// Verifica se o estado do botão mudou\;
		\Se{leitura $\neq$ estado\_anterior}{
			// Verifica se passou o tempo de debounce (50ms)\;
			\Se{(tempo\_atual - tempo\_anterior) > 50}{
				// Detecta transição HIGH $\rightarrow$ LOW (pressão)\;
				\Se{leitura = LOW \textbf{e} estado\_anterior = HIGH}{
					pressionado $\leftarrow$ verdadeiro\;
				}
				estado\_anterior $\leftarrow$ leitura\;
			}
			tempo\_anterior $\leftarrow$ tempo\_atual\;
		}
	}
\end{algorithm}

\subsection{Sistema de Force Feedback}
\label{subsec:ff-simulador}

O motor DC 775 de 24V do volante é controlado por ponte H BTS7960, recebendo comandos de intensidade e direção do cliente PC via serial USB. O protocolo de comunicação utiliza formato texto:

\begin{verbatim}
FF_MOTOR:ESQUERDA:45    - 45% de força anti-horária
FF_MOTOR:DIREITA:80     - 80% de força horária
FF_MOTOR:NEUTRO:0       - Libera o volante
\end{verbatim}

A proteção contra back-EMF do BTS7960, descrita na \autoref{subsec:protecao-backemf-veiculo}, também se aplica ao motor de force feedback, permitindo que o operador gire o volante livremente quando o motor não está acionado.

\subsection{Calibração de Encoders}
\label{subsec:calibracao-simulador}

O sistema de calibração permite ajuste dos valores mínimo, máximo e centro de cada encoder, armazenados na EEPROM do ESP32. O protocolo de calibração opera via serial:

\begin{enumerate}
	\item Cliente envia \texttt{CAL\_START:THROTTLE/BRAKE/STEERING}
	\item ESP32 transmite valores brutos a 100Hz: \texttt{CAL\_THROTTLE:<valor>}
	\item Operador move o controle para posições extremas
	\item Cliente envia valores calibrados: \texttt{CAL\_SAVE:THROTTLE:min:max}
	\item ESP32 confirma: \texttt{CAL\_COMPLETE:THROTTLE}
\end{enumerate}

A estrutura de dados na EEPROM utiliza magic number (\texttt{0xCAFE}) e checksum para validação de integridade, com endereços separados para cada encoder (16 bytes cada).

\subsection{Comunicação Serial USB}
\label{subsec:serial-simulador}

A comunicação com o cliente PC utiliza USB serial a 115200 baud, operando em modo full-duplex. O ESP32 transmite dados de encoders e eventos de marcha, enquanto recebe comandos de force feedback e calibração. A taxa de atualização de 100Hz (10ms) garante responsividade adequada para controle em tempo real.

% ============================================================================
% ARQUITETURA DO CLIENTE (PC)
% ============================================================================
\section{Arquitetura do Cliente (PC)}
\label{sec:arquitetura-cliente}

O cliente PC atua como hub central do sistema, recebendo dados do veículo via UDP, processando telemetria, calculando force feedback e transmitindo comandos para simulador e veículo. O software foi desenvolvido em Python 3.11.2 utilizando o editor Visual Studio Code, com interface gráfica Tkinter. O Python foi escolhido devido à facilidade de prototipagem e disponibilidade de bibliotecas para decodificação de vídeo, interface gráfica, processamento de imagens e comunicação. A \autoref{tab:bibliotecas-cliente} apresenta as principais bibliotecas utilizadas no desenvolvimento do cliente.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:bibliotecas-cliente} Bibliotecas Python utilizadas no cliente PC}
\IBGEtab{}{
\begin{tabular}{p{3.5cm}p{11cm}}
\toprule
\textbf{Biblioteca} & \textbf{Função} \\
\midrule
tkinter & Interface gráfica nativa com suporte a widgets e canvas para vídeo \\
opencv-python & Decodificação de frames MJPEG e aplicação de filtros de imagem \\
numpy & Processamento numérico de dados de telemetria e operações matriciais \\
cupy & Aceleração GPU para filtros PDI via CUDA (opcional) \\
Pillow & Conversão de imagens OpenCV para formato compatível com Tkinter \\
pyserial & Comunicação serial com ESP32 para recepção de dados do simulador \\
socket & Comunicação UDP com Raspberry Pi para recepção de telemetria e vídeo \\
matplotlib & Renderização de gráficos de telemetria em tempo real \\
\bottomrule
\end{tabular}
}{
\Fonte{elaborado pelo autor.}
}
\end{table}

\subsection{Especificações da Estação Cliente}
\label{subsec:componentes-cliente}

A \autoref{tab:componentes-cliente} apresenta as especificações do computador utilizado como estação cliente, responsável pelo processamento de telemetria, decodificação de vídeo MJPEG e cálculo de algoritmos de force feedback.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:componentes-cliente} Especificações da estação cliente}
\IBGEtab{}{%
	\begin{tabular}{p{3.5cm}p{6cm}p{6cm}}
		\toprule
		Componente & Especificação & Função no Sistema \\
		\midrule \midrule
		Notebook & Acer Nitro V 15 ANV15-51 & Plataforma de desenvolvimento e execução do cliente \\
		\midrule
		Processador & Intel Core i5-13420H (13ª geração), 8 núcleos (4P+4E), 12 threads, até 4.6GHz & Processamento de telemetria, interface gráfica e algoritmos de force feedback \\
		\midrule
		GPU Dedicada & NVIDIA GeForce RTX 3050 6GB GDDR6 (GA107BM) & Aceleração de processamento de imagem e renderização da interface \\
		\midrule
		GPU Integrada & Intel UHD Graphics (Raptor Lake-P) & Renderização secundária e economia de energia \\
		\midrule
		Memória RAM & 32GB DDR5 & Buffers de vídeo, histórico de telemetria e estruturas de dados \\
		\midrule
		Armazenamento & WD SN770 NVMe + Kingston NV1 NVMe & Armazenamento de logs, datasets e código fonte \\
		\midrule
		Sistema Operacional & Arch Linux, Kernel 6.18.2-arch2-1 & Ambiente de desenvolvimento com baixa latência e controle total do sistema \\
		\midrule
		Conectividade & WiFi 6 (802.11ax), USB 3.0 & Comunicação UDP com veículo e serial USB com simulador ESP32 \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

\subsection{Interface Gráfica}
\label{subsec:interface-cliente}

A interface gráfica utiliza layout de duas colunas: telemetria à esquerda e vídeo/controles à direita, conforme ilustrado na \autoref{fig:interface-geral}. A viabilidade técnica do streaming em tempo real com Raspberry Pi foi demonstrada por \citeonline{shendge2023development}, conforme apresentado na fundamentação teórica.

\begin{figure}[!ht]
	\captionsetup{width=16cm}
	\Caption{\label{fig:interface-geral} Interface gráfica do console de controle}
	\UFCfig{}{
		\includegraphics[width=15cm]{figuras/interface-geral}
	}{
		\Fonte{elaborado pelo autor.}
	}
\end{figure}

A coluna esquerda apresenta o status da conexão UDP e serial, painel de instrumentos com zona de eficiência, marcha atual, informações de energia, bateria e temperatura, dados brutos e físicos do sensor BMI160, forças G calculadas, velocidade estimada e componentes do cálculo de force feedback. A coluna direita exibe o vídeo da câmera em tempo real, filtros de processamento de imagem e gráficos de telemetria F1.

O painel de instrumentos exibe a porcentagem dentro da zona IDEAL de eficiência, marcha atual, posição do acelerador e velocidade estimada, atualizados em tempo real conforme dados recebidos do veículo e simulador. A visualização de vídeo utiliza OpenCV para decodificação MJPEG e Pillow para renderização no canvas Tkinter.

\subsection{Filtros de Processamento Digital de Imagens}
\label{subsec:filtros-pdi}

O cliente implementa um sistema de filtros de Processamento Digital de Imagens (PDI) combináveis, permitindo ao operador ativar múltiplos filtros simultaneamente via checkboxes na interface. Os filtros são aplicados em ordem otimizada para maximizar a qualidade visual do vídeo recebido do veículo.

A \autoref{tab:filtros-pdi} apresenta os filtros disponíveis no sistema, baseados em técnicas clássicas de processamento de imagens conforme \citeonline{gonzalez2010processamento}.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:filtros-pdi} Filtros de processamento digital de imagens disponíveis no cliente}
\IBGEtab{}{
\begin{tabular}{p{3cm}p{4cm}p{7cm}}
\toprule
\textbf{Filtro} & \textbf{Técnica} & \textbf{Descrição} \\
\midrule
Sharpen & Máscara Laplaciana 3×3 & Aguça bordas usando operador de segunda derivada \\
Unsharp Mask & Subtração gaussiana & Realça detalhes subtraindo versão borrada da imagem \\
High-Boost & Laplaciano ponderado & Aguçamento com preservação de baixas frequências \\
CLAHE & Equalização adaptativa & Melhora contraste local com limite de amplificação \\
Bilateral & Filtragem bilateral & Suaviza ruído preservando bordas \\
Super-Res 2x & Supersampling & Anti-aliasing via upscale/downscale Lanczos \\
Brilho +/- & Ajuste HSV & Modifica canal V para ambientes claros/escuros \\
\bottomrule
\end{tabular}
}{
\Fonte{elaborado pelo autor.}
}
\end{table}

O sistema suporta aceleração por GPU NVIDIA via biblioteca CuPy quando disponível, executando operações de convolução e transformações diretamente na placa de vídeo. Os filtros Sharpen, Unsharp Mask, High-Boost, Brilho e Super-Res utilizam GPU quando disponível, enquanto CLAHE e Bilateral executam em CPU devido à complexidade algorítmica. O fallback automático para CPU garante funcionamento em sistemas sem GPU dedicada.

\subsection{Recepção e Processamento de Dados}
\label{subsec:recepcao-cliente}

O cliente opera threads separadas para recepção UDP (veículo) e serial (simulador), com filas thread-safe para transferência de dados à thread principal de interface. O filtro por IP garante que apenas pacotes do veículo configurado sejam processados, ignorando tráfego de rede não relacionado.

\subsection{Algoritmos de Cálculo de Force Feedback}
\label{subsec:algoritmos-ff-cliente}

Os algoritmos de force feedback são executados no cliente, utilizando dados do sensor BMI160 recebidos do veículo para calcular intensidade e direção da força a ser aplicada no volante.

Embora algoritmos meta-heurísticos como LHHO e TLBO demonstrem vantagens conforme \citeonline{ayinla2024optimal}, optou-se por implementação direta dos algoritmos de force feedback devido às limitações computacionais e à necessidade de resposta em tempo real inferior a 5ms.

\subsubsection{Cálculo das Forças G}

O algoritmo para cálculo das forças G considera os valores de aceleração linear e velocidade angular obtidos do sensor BMI160:

\begin{equation}
\label{eq:forca-g-frontal-cliente}
G_{frontal} = \frac{acelera\text{ç}\tilde{a}o_{linear\_X}}{9.81}
\end{equation}

\begin{equation}
\label{eq:forca-g-lateral-cliente}
G_{lateral} = \frac{velocidade_{angular\_Z} \times velocidade_{linear}}{9.81}
\end{equation}

\subsubsection{Algoritmos de Controle de Force Feedback}
\label{sec:algoritmos-force-feedback}

Serão acumulados vários dados sobre os sensores para analisar todos os valores e assim descobrir os padrões para controle háptico dos atuadores; dessa forma, posso calibrar de forma mais parecida possível com o ambiente real. O giroscópio me permite calcular tanto a aceleração do veículo para os impulsos de força G lateral e frontal quanto calcular a posição do assoalho com relação à suspensão e emitir as vibrações do veículo, como segue de exemplo no artigo de \citeonline{dreger2024evaluation}, que investigaram diferentes designs de feedback para orientação em sistemas controlados por humanos, demonstrando que feedback em tempo real pode melhorar significativamente a precisão do operador sobre diferentes designs de feedback para orientação.

O algoritmo para cálculo das forças G considera os valores de aceleração linear e velocidade angular obtidos do sensor BMI160, aplicando normalização por G para obter valores em força gravitacional:

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:calcular-forcas-g}Cálculo das forças G}
	\Entrada{accel\_x, gyro\_z, velocidade}
	\Saida{g\_frontal, g\_lateral}
	\Inicio{
		// Leitura dos sensores\;
		accel\_x $\leftarrow$ ler\_acelerometro\_x()\;
		gyro\_z $\leftarrow$ ler\_giroscopio\_z()\;
		// Cálculo das forças G\;
		g\_frontal $\leftarrow$ accel\_x / 9.81\;
		g\_lateral $\leftarrow$ (gyro\_z $\times$ velocidade) / 9.81\;
		// Limitação de segurança\;
		\Se{g\_frontal > 2.0}{g\_frontal $\leftarrow$ 2.0\;}
		\Se{g\_lateral > 1.5}{g\_lateral $\leftarrow$ 1.5\;}
	}
\end{algorithm}

\subsubsection{Detecção de Vibrações}

Inclinações são movimentos lentos; vibrações são variações rápidas no sinal. Filtros temporais são utilizados onde médias de janelas pequenas capturam inclinações, e diferenças entre amostras capturam vibrações:

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:detectar-vibracoes}Detecção de vibrações}
	\Entrada{buffer\_accel[10]}
	\Saida{media\_lenta, variacao\_rapida}
	\Inicio{
		// Calcular média (inclinação)\;
		media\_lenta $\leftarrow$ 0\;
		\Para{i de 0 até 9}{
			media\_lenta $\leftarrow$ media\_lenta + buffer\_accel[i]\;
		}
		media\_lenta $\leftarrow$ media\_lenta / 10\;
		// Calcular variação (vibração)\;
		variacao\_rapida $\leftarrow$ abs(buffer\_accel[9] - buffer\_accel[8])\;
		escreva("Inclinação: ", media\_lenta)\;
		escreva("Vibração: ", variacao\_rapida)\;
	}
\end{algorithm}

\subsubsection{Controle dos Atuadores}

O mapeamento linear multiplica força G por ganho e soma ao centro PWM (127) para posição neutra:

\begin{equation}
\label{eq:pwm-saida}
PWM_{saida} = PWM_{centro} + (For\text{ç}a_G \times Ganho_{calibra\text{ç}\tilde{a}o})
\end{equation}

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:controlar-atuadores}Controle dos atuadores}
	\Entrada{g\_frontal, g\_lateral}
	\Saida{pwm\_frontal, pwm\_lateral}
	\Inicio{
		PWM\_CENTRO $\leftarrow$ 127\;
		GANHO $\leftarrow$ 80\;
		// Conversão G para PWM\;
		pwm\_frontal $\leftarrow$ PWM\_CENTRO + (g\_frontal $\times$ GANHO)\;
		pwm\_lateral $\leftarrow$ PWM\_CENTRO + (g\_lateral $\times$ GANHO)\;
		// Limitação PWM (0--255)\;
		\Se{pwm\_frontal > 255}{pwm\_frontal $\leftarrow$ 255\;}
		\Se{pwm\_frontal < 0}{pwm\_frontal $\leftarrow$ 0\;}
		// Envio para atuadores\;
		enviar\_pwm\_atuador(pwm\_frontal)\;
	}
\end{algorithm}

\subsubsection{Suavização de Movimento}

Para evitar movimentos bruscos, aplica-se transição gradual implementando resposta de primeira ordem para transições graduais:

\begin{equation}
\label{eq:suavizacao}
PWM_{atual} = PWM_{atual} + (PWM_{target} - PWM_{atual}) \times Taxa_{suaviza\text{ç}\tilde{a}o}
\end{equation}

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:suavizar-movimento}Suavização de movimento}
	\Entrada{pwm\_target, pwm\_atual}
	\Saida{pwm\_atual atualizado}
	\Inicio{
		TAXA\_SUAVE $\leftarrow$ 0.3\;
		// Transição suave em direção ao valor target\;
		pwm\_atual $\leftarrow$ pwm\_atual + ((pwm\_target - pwm\_atual) $\times$ TAXA\_SUAVE)\;
		enviar\_pwm\_atuador(pwm\_atual)\;
	}
\end{algorithm}

\subsubsection{Geração de Vibrações}

Vibração senoidal modulada pela intensidade detectada gera vibrações realistas usando função seno com frequência típica de 25Hz:

\begin{equation}
\label{eq:vibracao}
Vibra\text{ç}\tilde{a}o = Amplitude \times \sin(2\pi \times Frequ\hat{e}ncia \times Tempo)
\end{equation}

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:gerar-vibracao}Geração de vibrações}
	\Entrada{intensidade}
	\Saida{vibracao aplicada}
	\Inicio{
		FREQ\_VIB $\leftarrow$ 25\;
		LIMIAR $\leftarrow$ 0.1\;
		\Se{intensidade > LIMIAR}{
			amplitude $\leftarrow$ intensidade $\times$ 200\;
			tempo $\leftarrow$ obter\_tempo\_segundos()\;
			vibracao $\leftarrow$ amplitude $\times$ seno(2 $\times$ 3.14159 $\times$ FREQ\_VIB $\times$ tempo)\;
			pwm\_atual $\leftarrow$ pwm\_atual + vibracao\;
		}
	}
\end{algorithm}

\subsubsection{Calibração Automática de Ganhos}

Ajuste automático dos ganhos baseado na atividade detectada. A calibração adaptativa monitora atividade média e ajusta ganhos automaticamente para manter resposta adequada:

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:calibracao-auto}Calibração automática}
	\Entrada{media\_atividade}
	\Saida{GANHO ajustado}
	\Inicio{
		GANHO $\leftarrow$ 80\;
		// Análise da atividade média\;
		\Se{media\_atividade > 0.5}{
			GANHO $\leftarrow$ GANHO $\times$ 0.8\;
			escreva("Reduzindo sensibilidade")\;
		}
		\SenaoSe{media\_atividade < 0.1}{
			GANHO $\leftarrow$ GANHO $\times$ 1.2\;
			escreva("Aumentando sensibilidade")\;
		}
	}
\end{algorithm}

\subsubsection{Algoritmo Completo de Force Feedback da Direção}

O sistema de force feedback da direção combina três componentes principais: força lateral (curvas), rotação yaw e mola de centralização. O algoritmo é executado no cliente PC e envia comandos para o motor DC 775 do simulador via ESP32:

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:ff-direcao}Cálculo do force feedback da direção}
	\Entrada{g\_lateral, gyro\_z, angulo\_direcao, sensibilidade, friccao, filtro, damping}
	\Saida{intensidade\_ff, direcao\_ff}
	\Inicio{
		// Componente 1: Força lateral (curvas) - máximo 100\%\;
		componente\_lateral $\leftarrow$ minimo(abs(g\_lateral) $\times$ 50, 100)\;
		// Componente 2: Rotação yaw - máximo 50\%\;
		componente\_yaw $\leftarrow$ minimo(abs(gyro\_z) / 60.0 $\times$ 50, 50)\;
		// Componente 3: Mola de centralização - máximo 40\%\;
		razao\_angulo $\leftarrow$ abs(angulo\_direcao) / 100.0\;
		componente\_centragem $\leftarrow$ razao\_angulo $\times$ 40\;
		// Força base combinada (0-100\%)\;
		ff\_base $\leftarrow$ minimo(componente\_lateral + componente\_yaw + componente\_centragem, 100)\;
		// Aplica sensibilidade\;
		ff\_ajustado $\leftarrow$ ff\_base $\times$ sensibilidade\;
		// Aplica fricção baseada na rotação\;
		forca\_friccao $\leftarrow$ minimo(abs(gyro\_z) / 100.0, 1.0) $\times$ friccao $\times$ 30\;
		ff\_ajustado $\leftarrow$ minimo(ff\_ajustado + forca\_friccao, 100.0)\;
		// Aplica filtro (suavização exponencial)\;
		ff\_ajustado $\leftarrow$ ff\_ajustado $\times$ (1.0 - filtro) + ff\_filtrado\_anterior $\times$ filtro\;
		// Aplica damping (média móvel)\;
		intensidade\_ff $\leftarrow$ ff\_ajustado $\times$ (1.0 - damping) + ff\_anterior $\times$ damping\;
		// Determina direção do force feedback\;
		valor\_direcao $\leftarrow$ (-angulo\_direcao) + (g\_lateral $\times$ 10) + gyro\_z\;
		\Se{valor\_direcao > 5}{direcao\_ff $\leftarrow$ "DIREITA"\;}
		\SenaoSe{valor\_direcao < -5}{direcao\_ff $\leftarrow$ "ESQUERDA"\;}
		\Senao{direcao\_ff $\leftarrow$ "NEUTRO"\;}
	}
\end{algorithm}

\subsubsection{Cálculo de Velocidade por Integração}

A velocidade do veículo é estimada através da integração numérica da aceleração medida pelo sensor BMI160. Um fator de decaimento é aplicado para simular atrito e resistência do ar:

\begin{equation}
\label{eq:velocidade-integracao}
v(t) = v(t-1) + a \times \Delta t
\end{equation}

\begin{equation}
\label{eq:velocidade-decaimento}
v_{final} = v(t) \times fator_{decaimento}
\end{equation}

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:calcular-velocidade}Cálculo de velocidade por integração}
	\Entrada{accel\_x, accel\_y, tempo\_atual}
	\Saida{velocidade\_total\_kmh}
	\Inicio{
		LIMIAR\_ACCEL $\leftarrow$ 0.1\;
		FATOR\_DECAIMENTO $\leftarrow$ 0.995\;
		LIMIAR\_VELOCIDADE $\leftarrow$ 0.01\;
		// Calcula delta time\;
		dt $\leftarrow$ tempo\_atual - tempo\_anterior\;
		tempo\_anterior $\leftarrow$ tempo\_atual\;
		// Filtra ruído da aceleração\;
		\Se{abs(accel\_x) < LIMIAR\_ACCEL}{accel\_x $\leftarrow$ 0\;}
		\Se{abs(accel\_y) < LIMIAR\_ACCEL}{accel\_y $\leftarrow$ 0\;}
		// Integração: v = v0 + a $\times$ dt\;
		velocidade\_x $\leftarrow$ velocidade\_x + accel\_x $\times$ dt\;
		velocidade\_y $\leftarrow$ velocidade\_y + accel\_y $\times$ dt\;
		// Aplica decaimento (simula atrito)\;
		velocidade\_x $\leftarrow$ velocidade\_x $\times$ FATOR\_DECAIMENTO\;
		velocidade\_y $\leftarrow$ velocidade\_y $\times$ FATOR\_DECAIMENTO\;
		// Zera velocidades muito pequenas\;
		\Se{abs(velocidade\_x) < LIMIAR\_VELOCIDADE}{velocidade\_x $\leftarrow$ 0\;}
		\Se{abs(velocidade\_y) < LIMIAR\_VELOCIDADE}{velocidade\_y $\leftarrow$ 0\;}
		// Calcula magnitude e converte para km/h\;
		velocidade\_ms $\leftarrow$ raiz(velocidade\_x$^2$ + velocidade\_y$^2$)\;
		velocidade\_total\_kmh $\leftarrow$ velocidade\_ms $\times$ 3.6\;
	}
\end{algorithm}

\subsection{Sistema de Telemetria em Tempo Real}
\label{subsec:telemetria-cliente}

O sistema de telemetria exibe gráficos estilo Fórmula 1 em tempo real utilizando a biblioteca Matplotlib integrada ao Tkinter. Os dados são armazenados em buffers circulares (\textit{deque}) com capacidade máxima de 500 pontos, representando aproximadamente 50 segundos de histórico a 10Hz:

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:atualizar-telemetria}Atualização dos gráficos de telemetria}
	\Entrada{dados\_sensores}
	\Saida{graficos\_atualizados}
	\Inicio{
		MAX\_PONTOS $\leftarrow$ 500\;
		JANELA\_TEMPO $\leftarrow$ 30\;
		// Calcula tempo relativo desde o início\;
		tempo\_atual $\leftarrow$ tempo\_sistema() - tempo\_inicio\;
		// Adiciona dados aos buffers circulares\;
		buffer\_tempo.adicionar(tempo\_atual)\;
		buffer\_velocidade.adicionar(dados\_sensores["velocidade"])\;
		buffer\_acelerador.adicionar(dados\_sensores["acelerador"])\;
		buffer\_freio.adicionar(dados\_sensores["freio"])\;
		buffer\_g\_lateral.adicionar(dados\_sensores["g\_lateral"])\;
		buffer\_g\_frontal.adicionar(dados\_sensores["g\_frontal"])\;
		// Ajusta janela de visualização (últimos 30 segundos)\;
		x\_min $\leftarrow$ maximo(0, tempo\_atual - JANELA\_TEMPO)\;
		x\_max $\leftarrow$ tempo\_atual + 1\;
		// Atualiza linhas dos gráficos\;
		linha\_velocidade.atualizar(buffer\_tempo, buffer\_velocidade)\;
		linha\_acelerador.atualizar(buffer\_tempo, buffer\_acelerador)\;
		linha\_freio.atualizar(buffer\_tempo, buffer\_freio)\;
		linha\_g\_lateral.atualizar(buffer\_tempo, buffer\_g\_lateral)\;
		linha\_g\_frontal.atualizar(buffer\_tempo, buffer\_g\_frontal)\;
		// Redesenha canvas\;
		canvas.redesenhar()\;
	}
\end{algorithm}

\subsection{Sistema de Auto-Save e Exportação de Dados}
\label{subsec:autosave-cliente}

O sistema implementa salvamento automático periódico a cada 20 segundos, exportando logs, dados de sensores e telemetria em formato Pickle (binário Python), que oferece performance 5--10x superior ao CSV para serialização de estruturas de dados complexas:

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:auto-save}Auto-save periódico de dados}
	\Entrada{console, intervalo\_ms}
	\Saida{arquivos\_salvos}
	\Inicio{
		MIN\_LOGS $\leftarrow$ 10\;
		MIN\_SENSORES $\leftarrow$ 100\;
		MIN\_TELEMETRIA $\leftarrow$ 50\;
		DIRETORIO $\leftarrow$ "exports/auto/"\;
		// Verifica se há dados novos suficientes\;
		qtd\_logs $\leftarrow$ contar\_linhas(console.log\_text)\;
		qtd\_sensores $\leftarrow$ tamanho(sensor\_display.historico)\;
		qtd\_telemetria $\leftarrow$ tamanho(telemetria.buffer\_tempo)\;
		// Só salva se atingir mínimo E houver dados novos\;
		\Se{(qtd\_logs $\geq$ MIN\_LOGS) OU (qtd\_sensores $\geq$ MIN\_SENSORES) OU (qtd\_telemetria $\geq$ MIN\_TELEMETRIA)}{
			timestamp $\leftarrow$ formato\_data("YYYYMMDD\_HHMMSS")\;
			// Salva logs em texto\;
			\Se{qtd\_logs $\geq$ MIN\_LOGS}{
				salvar\_arquivo(DIRETORIO + "logs\_" + timestamp + ".txt", console.log\_text)\;
			}
			// Salva sensores em Pickle (binário)\;
			\Se{qtd\_sensores $\geq$ MIN\_SENSORES}{
				pickle.salvar(DIRETORIO + "sensors\_" + timestamp + ".pkl", sensor\_display.historico)\;
			}
			// Salva telemetria em Pickle\;
			\Se{qtd\_telemetria $\geq$ MIN\_TELEMETRIA}{
				pickle.salvar(DIRETORIO + "telemetry\_" + timestamp + ".pkl", telemetria.dados)\;
			}
			// Limpa buffers após salvar\;
			console.log\_text.limpar()\;
			sensor\_display.resetar()\;
			telemetria.resetar()\;
		}
		// Reagenda próximo auto-save\;
		agendar(intervalo\_ms, auto\_save)\;
	}
\end{algorithm}

A estrutura dos arquivos Pickle exportados permite fácil leitura posterior para análise:

\begin{verbatim}
import pickle
with open("sensors_20241216_143000.pkl", "rb") as f:
    dados = pickle.load(f)
# dados contém dicionário com listas de cada sensor
\end{verbatim}

\section{Armazenamento de Logs e Validação}
\label{sec:logs-validacao}

O sistema de armazenamento de dados implementa salvamento automático periódico para garantir a preservação de informações de telemetria durante as sessões de operação. Os dados armazenados permitem validação das telemetrias entre corridas e análise posterior, de forma similar às equipes de Fórmula 1 que utilizam dados de sessões para otimização de desempenho.

\subsection{Sistema de Auto-Save}
\label{subsec:sistema-autosave}

O cliente implementa um mecanismo de salvamento automático que opera a cada 20 segundos, exportando três categorias de dados: logs do console, leituras brutas de sensores e dados processados de telemetria. A escolha do intervalo de 20 segundos representa um equilíbrio entre frequência de salvamento (proteção contra perda de dados em caso de falha) e volume de arquivos gerados, resultando em aproximadamente 180 arquivos por hora de operação contínua.

O sistema utiliza thresholds mínimos para evitar salvamento de arquivos vazios ou com dados insuficientes: 100 linhas de log, 1000 leituras de sensores (10 segundos a 100Hz) ou 100 pontos de telemetria (10 segundos a 10Hz). Após cada salvamento, os buffers internos são limpos automaticamente para liberar memória e reiniciar a coleta.

\subsection{Formatos de Armazenamento}
\label{subsec:formatos-armazenamento}

A seleção dos formatos de armazenamento considerou velocidade de serialização, tamanho dos arquivos e facilidade de processamento posterior. A \autoref{tab:formatos-armazenamento} apresenta os formatos utilizados para cada tipo de dado.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:formatos-armazenamento} Formatos de armazenamento utilizados no sistema de auto-save}
\IBGEtab{}{%
	\begin{tabular}{p{3cm}p{2.5cm}p{4cm}p{5cm}}
		\toprule
		Tipo de Dado & Formato & Nomenclatura & Justificativa \\
		\midrule \midrule
		Logs do console & Texto (.txt) & \texttt{logs\_YYYYMMDD\_HHMMSS.txt} & Legibilidade humana, facilidade de inspeção \\
		\midrule
		Sensores brutos & Pickle (.pkl) & \texttt{sensors\_YYYYMMDD\_HHMMSS.pkl} & Velocidade 5--10$\times$ superior ao CSV \\
		\midrule
		Telemetria & Pickle (.pkl) & \texttt{telemetry\_YYYYMMDD\_HHMMSS.pkl} & Preservação de estruturas Python complexas \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

O formato Pickle foi escolhido para dados numéricos por oferecer serialização binária nativa do Python, com velocidade 5 a 10 vezes superior ao CSV para estruturas de dados complexas contendo listas e dicionários aninhados. Embora o Pickle não seja legível por humanos, a análise dos dados é realizada através de scripts Python que reconstroem as estruturas originais. Os arquivos de log mantêm formato texto para permitir inspeção manual rápida durante depuração.

\subsection{Estrutura dos Dados Armazenados}
\label{subsec:estrutura-dados-armazenados}

Os arquivos de sensores contêm dicionários Python com listas de valores para cada canal do sensor BMI160 e do sistema de monitoramento de energia: \texttt{timestamp}, \texttt{bmi160\_accel\_x}, \texttt{bmi160\_accel\_y}, \texttt{bmi160\_accel\_z}, \texttt{bmi160\_gyro\_x}, \texttt{bmi160\_gyro\_y}, \texttt{bmi160\_gyro\_z}, \texttt{g\_force\_lateral}, \texttt{g\_force\_frontal}, \texttt{current\_motor}, \texttt{current\_servos}, \texttt{current\_rpi}, \texttt{power\_total} e \texttt{voltage\_rpi}. Cada lista contém valores correspondentes ao mesmo índice temporal, permitindo correlação entre diferentes grandezas.

Os arquivos de telemetria armazenam dados processados para os gráficos da interface: \texttt{time}, \texttt{speed}, \texttt{throttle}, \texttt{brake}, \texttt{g\_lateral}, \texttt{g\_frontal} e metadados como \texttt{start\_time}, \texttt{points\_count} e \texttt{export\_time}. Esses dados representam valores já filtrados e normalizados, prontos para visualização.

\subsection{Script de Análise de Sessões}
\label{subsec:script-analise-sessoes}

O script \texttt{analyze\_session.py} foi desenvolvido para processar os arquivos gerados pelo sistema de auto-save, oferecendo análise estatística e visualização gráfica das sessões de operação. O script suporta três modos de operação: análise combinada de todos os arquivos do diretório (padrão), análise apenas dos arquivos mais recentes e análise de timestamp específico.

O processamento combina múltiplos arquivos Pickle em estruturas unificadas, concatenando as listas de cada canal para formar séries temporais contínuas. As estatísticas calculadas incluem duração total da sessão, velocidade máxima, média e mínima, tempo em aceleração total (\textit{full throttle}), tempo em frenagem, forças G laterais e frontais máximas, acelerações e velocidades angulares extremas, e consumo de energia quando disponível.

A visualização gráfica utiliza a biblioteca Matplotlib com estilo visual inspirado nas telemetrias de Fórmula 1, apresentando gráficos de velocidade ao longo do tempo, utilização de pedais, forças G, distribuição de velocidade em histograma e diagrama G-G (\textit{scatter plot} de força lateral versus frontal). A análise de logs identifica padrões de erros, avisos, conexões e desconexões através de expressões regulares.

O script também suporta exportação de relatório HTML formatado contendo todas as estatísticas e metadados da sessão, facilitando documentação e compartilhamento dos resultados experimentais. A \autoref{alg:analise-sessao} apresenta o fluxo principal do processamento.

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:analise-sessao}Análise de sessão de telemetria}
	\Entrada{diretório de dados, modo de operação}
	\Saida{estatísticas, gráficos, relatório}
	\Inicio{
		// Localiza arquivos por padrão de nomenclatura\;
		arquivos\_telemetria $\leftarrow$ glob("telemetry\_*.pkl")\;
		arquivos\_sensores $\leftarrow$ glob("sensors\_*.pkl")\;
		arquivos\_logs $\leftarrow$ glob("logs\_*.txt")\;
		// Carrega e combina dados de múltiplos arquivos\;
		dados\_combinados $\leftarrow$ dicionário vazio\;
		\Para{cada arquivo em arquivos\_telemetria}{
			dados $\leftarrow$ pickle.load(arquivo)\;
			\Para{cada chave, valores em dados}{
				dados\_combinados[chave].estender(valores)\;
			}
		}
		// Calcula estatísticas com NumPy\;
		velocidade $\leftarrow$ array(dados\_combinados["speed"])\;
		estatisticas.velocidade\_max $\leftarrow$ max(velocidade)\;
		estatisticas.velocidade\_media $\leftarrow$ media(velocidade)\;
		// Gera gráficos estilo F1\;
		plotar\_telemetria(dados\_combinados)\;
		plotar\_sensores(dados\_sensores)\;
		// Exporta relatório HTML\;
		exportar\_html(estatisticas, analise\_logs)\;
	}
\end{algorithm}

A leitura dos arquivos Pickle para análise externa pode ser realizada através do seguinte código Python:

\begin{verbatim}
import pickle
with open("sensors_20241216_143000.pkl", "rb") as f:
    dados = pickle.load(f)
# dados contém dicionário com listas de cada sensor
print(dados.keys())  # ['timestamp', 'bmi160_accel_x', ...]
print(len(dados['timestamp']))  # Quantidade de amostras
\end{verbatim}

\subsection{Métricas de Validação Extraídas}
\label{subsec:metricas-validacao}

Os dados armazenados pelo sistema de auto-save permitem a extração de métricas específicas para validação do desempenho do sistema. A \autoref{tab:metricas-validacao} apresenta as métricas extraídas de cada categoria de dados, organizadas por subsistema avaliado.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:metricas-validacao} Métricas de validação extraídas dos dados armazenados}
\IBGEtab{}{%
	\begin{tabular}{p{3cm}p{4cm}p{4cm}p{4cm}}
		\toprule
		Subsistema & Métrica & Fonte de Dados & Cálculo \\
		\midrule \midrule
		\multirow{3}{*}{Comunicação} & Latência média & \texttt{timestamp} & Diferença entre envio e recepção \\
		& Jitter & \texttt{timestamp} & Desvio padrão dos intervalos \\
		& Packet loss & \texttt{logs\_*.txt} & Contagem de erros de recepção \\
		\midrule
		\multirow{3}{*}{Vídeo} & FPS efetivo & \texttt{telemetry\_*.pkl} & Frames por segundo médio \\
		& Estabilidade & \texttt{telemetry\_*.pkl} & Variância do intervalo entre frames \\
		& Throughput & \texttt{sensors\_*.pkl} & Bytes por segundo \\
		\midrule
		\multirow{3}{*}{Sensores} & Taxa de amostragem & \texttt{sensors\_*.pkl} & Amostras por segundo \\
		& Drift térmico & \texttt{temperature} & Variação ao longo do tempo \\
		& Ruído & \texttt{bmi160\_accel\_*} & Desvio padrão em repouso \\
		\midrule
		\multirow{3}{*}{Force Feedback} & Tempo de resposta & \texttt{timestamp} & Latência comando-atuação \\
		& Precisão & \texttt{g\_force\_*} & Correlação sensor-feedback \\
		& Estabilidade & \texttt{gyro\_z} & Variância em regime permanente \\
		\midrule
		\multirow{2}{*}{Energia} & Consumo médio & \texttt{power\_total} & Média de potência \\
		& Pico de corrente & \texttt{current\_motor} & Valor máximo registrado \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

O script \texttt{analyze\_session.py} calcula automaticamente as estatísticas principais a partir dos dados armazenados. Para métricas de comunicação, o intervalo entre timestamps consecutivos permite estimar a latência efetiva do sistema, enquanto o desvio padrão desses intervalos caracteriza o jitter. A análise de logs por expressões regulares identifica eventos de erro, permitindo cálculo da taxa de perda de pacotes.

Para validação estatística dos resultados, o volume de dados coletado pelo sistema de auto-save garante robustez. Considerando taxa de amostragem de 100Hz para sensores e sessões típicas de 15 minutos, cada sessão gera aproximadamente 90.000 pontos de telemetria. Esse volume supera significativamente o mínimo de 384 amostras requerido para população infinita com 95\% de confiança e margem de erro de 5\%, proporcionando poder estatístico superior a 99\% para detectar diferenças com tamanho de efeito médio nas comparações com o estado da arte.

\section{Reprodutibilidade e Transparência Experimental}
\label{sec:reprodutibilidade-transparencia}

A garantia de reprodutibilidade científica constitui um pilar fundamental para a validação e evolução do conhecimento em engenharia de sistemas embarcados. Seguindo as diretrizes estabelecidas por \citeonline{graf2024monitoring} para avaliação de desempenho de sistemas wireless, este trabalho adota protocolos rigorosos de documentação e disponibilização de recursos para permitir a replicação completa dos experimentos realizados.

\subsection{Disponibilização de Código Fonte e Datasets}
\label{subsec:codigo-datasets}

Todo o código fonte desenvolvido para este projeto está disponibilizado publicamente no repositório GitHub sob licença MIT, acessível em \url{https://github.com/inacio-dev/tcc}. O repositório contém a estrutura completa do projeto, organizada conforme a \autoref{tab:estrutura-repositorio}.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:estrutura-repositorio} Estrutura do repositório de código fonte}
\IBGEtab{}{%
	\begin{tabular}{p{3.5cm}p{11cm}}
		\toprule
		Diretório & Conteúdo \\
		\midrule \midrule
		\texttt{raspberry/} & Scripts Python para controle do Raspberry Pi 4: captura de vídeo, leitura de sensores BMI160, controle de motor e servos, comunicação UDP \\
		\midrule
		\texttt{client/} & Interface gráfica em Python/Tkinter, recepção UDP, processamento de telemetria, sistema de auto-save e script de análise de sessões \\
		\midrule
		\texttt{esp32/} & Firmware C++ para ESP32: leitura de encoders, controle de force feedback, comunicação serial USB \\
		\midrule
		\texttt{exports/auto/} & Datasets de telemetria em formato Pickle (.pkl) e logs de sessões (.txt) \\
		\midrule
		\texttt{scripts/} & Rotinas de análise estatística e geração de gráficos \\
		\midrule
		\texttt{docs/} & Documentação técnica das decisões de projeto \\
		\midrule
		\texttt{monografia/} & Código fonte \LaTeX\ deste documento \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

Conforme demonstrado por \citeonline{bobrovsky2023development}, a transparência no desenvolvimento de sistemas embarcados facilita a reprodução e melhoria contínua das soluções propostas. Os datasets coletados durante as sessões experimentais, totalizando mais de 90.000 pontos de telemetria, estão disponíveis no diretório \texttt{exports/auto/} do repositório em formato Pickle, permitindo análise direta com o script \texttt{analyze\_session.py} incluso no projeto.

\subsection{Protocolo Detalhado de Replicação}
\label{subsec:protocolo-replicacao}

O protocolo de replicação experimental documentado contempla todos os aspectos críticos para reprodução fidedigna dos resultados obtidos. As especificações de hardware incluem números de modelo exatos, versões de firmware e configurações específicas de cada componente utilizado no sistema. Para o Raspberry Pi 4, documenta-se a versão do Raspberry Pi OS (Bullseye 64-bit), kernel utilizado (5.15.84-v8+) e configurações específicas do arquivo config.txt para otimização da câmera OV5647.

As configurações de rede wireless seguem padrões reproduzíveis, especificando canal WiFi (2.4GHz canal 6), potência de transmissão (20dBm), tipo de roteador utilizado (TP-Link Archer C6) e posicionamento físico dos equipamentos. As condições ambientais durante os experimentos são registradas detalhadamente, incluindo temperatura ambiente (22±2°C), umidade relativa (45±5\%), interferências eletromagnéticas medidas e layout físico do ambiente de teste.

\subsection{Documentação de Configurações Ambientais}
\label{subsec:configuracoes-ambientais}

As configurações ambientais experimentais são registradas sistematicamente para garantir reprodutibilidade das condições de teste. O ambiente de rede é caracterizado através de medições de potência de sinal WiFi utilizando ferramentas como iwconfig e wavemon, documentando valores de RSSI (Received Signal Strength Indicator) em múltiplos pontos do ambiente experimental.

As características do ambiente físico incluem dimensões precisas do local de teste (5m × 8m), materiais de construção das paredes (alvenaria com reboco), presença de obstáculos metálicos e fontes potenciais de interferência eletromagnética. O posicionamento relativo entre veículo teleoperado e estação de controle é documentado com coordenadas precisas, utilizando sistema de referência baseado em marcos físicos permanentes.

As condições de iluminação para os testes de câmera são padronizadas utilizando iluminação artificial controlada (lâmpadas LED 6500K, 1000 lúmens), minimizando variações devido à iluminação natural. Os padrões de teste visual incluem alvos de calibração com dimensões conhecidas, permitindo validação da qualidade de captura de vídeo independente das condições específicas do ambiente.

O controle de temperatura ambiente utiliza sistema de climatização para manter estabilidade térmica durante as sessões experimentais, evitando drift térmico excessivo nos sensores. Registros contínuos de temperatura e umidade são mantidos através de datalogger dedicado, correlacionando variações ambientais com performance do sistema.
