\chapter{Metodologia}
\label{chap:metodologia}

Será realizado um desenvolvimento incremental e modular de um simulador completo de um carrinho de Fórmula 1 com cockpit, sendo o carrinho controlado via protocolo UDP. Utilizarei uma metodologia de prototipagem evolutiva, que busca o teste individual de cada componente antes da integração final. O projeto busca um objetivo semelhante ao artigo de \citeonline{shaik2025design}, que também desenvolveu um sistema de controle completo para veículos usando single board computer, integrando Raspberry Pi 5 para controle de movimento e direção com operação bem-sucedida em velocidades de até 40 km/h\@.

O projeto seguirá uma arquitetura de três camadas: o carrinho com o elemento principal sendo o Raspberry Pi 4 terá o objetivo de receber mensagens de controle e enviar mensagens de vídeo e status de sensores; a comunicação entre o carrinho e o cliente será feita por protocolo UDP\@; e, por último, o PC (cliente) receberá as mensagens e encaminhará os comandos de status para o simulador, bem como encaminhará as mensagens de controle para o carrinho. A utilização dos sensores e integração de múltiplos sensores visa um bom resultado de feedback ao usuário, como no artigo de \citeonline{bobrovsky2023development}, que desenvolveram um módulo universal para conectar até 16 sensores em um carro elétrico Formula Student, reduzindo significativamente a complexidade da fiação e garantindo transmissão segura de dados através do protocolo CAN\@.

\section{Especificações dos Componentes}\label{sec:especificacoes}

A \autoref{tab:componentes} apresenta as especificações detalhadas dos componentes utilizados no sistema, definindo suas funções específicas na arquitetura do projeto.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:componentes} Especificações dos componentes utilizados no sistema}
\IBGEtab{}{%
	\begin{tabular}{p{3.5cm}p{6cm}p{6cm}}
		\toprule
		Componente & Especificação & Função no Sistema \\
		\midrule \midrule
		Raspberry Pi 4 Model B & Broadcom BCM2711, Quad core Cortex-A72 64-bit @ 1.8GHz, 4GB RAM & Núcleo de controle e comunicação do carrinho, servidor UDP, processamento de vídeo e controle de sensores \\
		\midrule
		Arduino Mega 2560 R3 WiFi & ATmega2560 + ESP8266, 16MHz, 54 I/O digitais, 16 analógicas, 256KB Flash & Controle de atuadores de force feedback e comunicação serial com cliente PC \\
		\midrule
		Câmera OV5647 & 5MP, 2592×1944 pixels, vídeo 1080p/30fps, interface CSI & Captura de vídeo em tempo real para transmissão via UDP \\
		\midrule
		Sensor BMI160 & IMU 6 eixos, ±2g/±250°/s, 16 bits, I2C/SPI & Detecção de forças G, aceleração e velocidade angular para force feedback \\
		\midrule
		Motor DC RS550 & 12V, 19.550 RPM & Propulsão principal do carrinho \\
		\midrule
		Motor DC 775 & 24V, 12.000 RPM & Geração de force feedback no volante do cockpit \\
		\midrule
		Ponte H BTS7960 & 5.5--27Vdc, corrente contínua 40A, proteção térmica integrada & Controle bidirecional de velocidade dos motores DC \\
		\midrule
		Servo MG996R & 4.8--7.2V, torque 11kg.cm, rotação 180°, velocidade 0.14s/60° & Controle de direção e sistema de freio do carrinho \\
		\midrule
		Caixa Diferencial HSP 1:10 & Modelo 94111/94123, relação 02051 & Transmissão diferencial para rodas traseiras do carrinho \\
		\midrule
		Amortecedores RC 1:10 & Compatível Axial SCX10/TRX4, óleo ajustável & Suspensão do carrinho e amortecimento dos pedais do cockpit \\
		\midrule
		Atuadores Lineares DC & 12V, força 1000N, curso 250mm, velocidade 14mm/s & Simulação de movimentos da pista e força G no cockpit \\
		\midrule
		Rolamento Unidirecional CSK8PP & $8\times22\times9$mm, uma direção de rotação & Proteção contra travamento por torque reverso no eixo de velocidade \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

\section{Protocolo de Comunicação UDP}\label{sec:protocolo-udp}

O UDP é um protocolo que lida com o alto envio de mensagens, muito utilizado para envio de streams e em jogos de computador. A arquitetura atual necessita de baixa latência, pois uma latência muito alta irá atrapalhar o controle em tempo real do carrinho, passando por um alto delay de comandos e prejudicando a experiência do usuário. Por causa dessa baixa latência, também demonstrada no artigo de \citeonline{lu2023udp}, que demonstrou que UDP-RT melhorou a latência de inicialização em 62\% e o tempo total de comunicação em 22\% comparado ao TCP, é que justifico o uso desse protocolo.

\subsection{Justificativa para UDP Simples}\label{subsec:justificativa-udp}

A escolha do UDP simples sobre protocolos mais avançados como UDP-RT \citeonline{lu2023udp} é justificada pela necessidade de simplicidade de implementação e recursos limitados do Raspberry Pi 4. Embora o UDP-RT ofereça melhorias de 62\% na latência de inicialização e 22\% no tempo total de comunicação, sua implementação aumentaria significativamente a complexidade do sistema. Conforme demonstrado nos resultados, a latência obtida de 1.94ms com UDP simples supera os targets típicos de 5ms, validando que esta abordagem é adequada para o projeto sem necessidade de complexidade adicional.

\section{Algoritmos de Controle de Force Feedback}\label{sec:algoritmos-force-feedback}

Serão acumulados vários dados sobre os sensores para analisar todos os valores e assim descobrir os padrões para controle háptico dos atuadores; dessa forma, posso calibrar de forma mais parecida possível com o ambiente real. O giroscópio me permite calcular tanto a aceleração do carro para os impulsos de força G lateral e frontal quanto calcular a posição do assoalho com relação à suspensão e emitir as vibrações do carro, como segue de exemplo no artigo de \citeonline{dreger2024evaluation}, que investigaram diferentes designs de feedback para orientação em sistemas controlados por humanos, demonstrando que feedback em tempo real pode melhorar significativamente a precisão do operador sobre diferentes designs de feedback para orientação.

\subsection{Justificativa para Abordagem Simplificada}\label{subsec:justificativa-algoritmos}

Embora o estado da arte demonstre a superioridade de algoritmos meta-heurísticos como LHHO e TLBO \citeonline{ayinla2024optimal}, optou-se por implementação direta dos algoritmos de force feedback devido às limitações computacionais do Raspberry Pi 4 e à necessidade de resposta em tempo real inferior a 5ms. A complexidade adicional dos algoritmos de otimização seria implementada em versões futuras com hardware mais robusto.

\begin{equation}
\label{eq:forca-g-frontal}
G_{frontal} = \frac{acelera\text{ç}\tilde{a}o_{linear\_X}}{9.81}
\end{equation}

\begin{equation}
\label{eq:forca-g-lateral}
G_{lateral} = \frac{velocidade_{angular\_Z} \times velocidade_{linear}}{9.81}
\end{equation}

\subsection{Algoritmo de Cálculo das Forças G}\label{subsec:calculo-forcas-g}

O algoritmo para cálculo das forças G considera os valores de aceleração linear e velocidade angular obtidos do sensor BMI160, aplicando normalização por G para obter valores em força gravitacional:

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:calcular-forcas-g}Cálculo das forças G}
	\Entrada{accel\_x, gyro\_z, velocidade}
	\Saida{g\_frontal, g\_lateral}
	\Inicio{
		// Leitura dos sensores\;
		accel\_x $\leftarrow$ ler\_acelerometro\_x()\;
		gyro\_z $\leftarrow$ ler\_giroscopio\_z()\;
		// Cálculo das forças G\;
		g\_frontal $\leftarrow$ accel\_x / 9.81\;
		g\_lateral $\leftarrow$ (gyro\_z $\times$ velocidade) / 9.81\;
		// Limitação de segurança\;
		\Se{g\_frontal > 2.0}{g\_frontal $\leftarrow$ 2.0\;}
		\Se{g\_lateral > 1.5}{g\_lateral $\leftarrow$ 1.5\;}
	}
\end{algorithm}

\subsection{Detecção de Vibrações}\label{subsec:deteccao-vibracoes}

Inclinações são movimentos lentos; vibrações são variações rápidas no sinal. Filtros temporais são utilizados onde médias de janelas pequenas capturam inclinações, e diferenças entre amostras capturam vibrações:

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:detectar-vibracoes}Detecção de vibrações}
	\Entrada{buffer\_accel[10]}
	\Saida{media\_lenta, variacao\_rapida}
	\Inicio{
		// Calcular média (inclinação)\;
		media\_lenta $\leftarrow$ 0\;
		\Para{i de 0 até 9}{
			media\_lenta $\leftarrow$ media\_lenta + buffer\_accel[i]\;
		}
		media\_lenta $\leftarrow$ media\_lenta / 10\;
		// Calcular variação (vibração)\;
		variacao\_rapida $\leftarrow$ abs(buffer\_accel[9] - buffer\_accel[8])\;
		escreva("Inclinação: ", media\_lenta)\;
		escreva("Vibração: ", variacao\_rapida)\;
	}
\end{algorithm}

\subsection{Controle dos Atuadores}\label{subsec:controle-atuadores}

O mapeamento linear multiplica força G por ganho e soma ao centro PWM (127) para posição neutra:

\begin{equation}
\label{eq:pwm-saida}
PWM_{saida} = PWM_{centro} + (For\text{ç}a_G \times Ganho_{calibra\text{ç}\tilde{a}o})
\end{equation}

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:controlar-atuadores}Controle dos atuadores}
	\Entrada{g\_frontal, g\_lateral}
	\Saida{pwm\_frontal, pwm\_lateral}
	\Inicio{
		PWM\_CENTRO $\leftarrow$ 127\;
		GANHO $\leftarrow$ 80\;
		// Conversão G para PWM\;
		pwm\_frontal $\leftarrow$ PWM\_CENTRO + (g\_frontal $\times$ GANHO)\;
		pwm\_lateral $\leftarrow$ PWM\_CENTRO + (g\_lateral $\times$ GANHO)\;
		// Limitação PWM (0--255)\;
		\Se{pwm\_frontal > 255}{pwm\_frontal $\leftarrow$ 255\;}
		\Se{pwm\_frontal < 0}{pwm\_frontal $\leftarrow$ 0\;}
		// Envio para atuadores\;
		enviar\_pwm\_atuador(pwm\_frontal)\;
	}
\end{algorithm}

\subsection{Suavização de Movimento}\label{subsec:suavizacao-movimento}

Para evitar movimentos bruscos, aplica-se transição gradual implementando resposta de primeira ordem para transições graduais:

\begin{equation}
\label{eq:suavizacao}
PWM_{atual} = PWM_{atual} + (PWM_{target} - PWM_{atual}) \times Taxa_{suaviza\text{ç}\tilde{a}o}
\end{equation}

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:suavizar-movimento}Suavização de movimento}
	\Entrada{pwm\_target, pwm\_atual}
	\Saida{pwm\_atual atualizado}
	\Inicio{
		TAXA\_SUAVE $\leftarrow$ 0.3\;
		// Transição suave em direção ao valor target\;
		pwm\_atual $\leftarrow$ pwm\_atual + ((pwm\_target - pwm\_atual) $\times$ TAXA\_SUAVE)\;
		enviar\_pwm\_atuador(pwm\_atual)\;
	}
\end{algorithm}

\subsection{Geração de Vibrações}\label{subsec:geracao-vibracoes}

Vibração senoidal modulada pela intensidade detectada gera vibrações realistas usando função seno com frequência típica de 25Hz:

\begin{equation}
\label{eq:vibracao}
Vibra\text{ç}\tilde{a}o = Amplitude \times \sin(2\pi \times Frequ\hat{e}ncia \times Tempo)
\end{equation}

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:gerar-vibracao}Geração de vibrações}
	\Entrada{intensidade}
	\Saida{vibracao aplicada}
	\Inicio{
		FREQ\_VIB $\leftarrow$ 25\;
		LIMIAR $\leftarrow$ 0.1\;
		\Se{intensidade > LIMIAR}{
			amplitude $\leftarrow$ intensidade $\times$ 200\;
			tempo $\leftarrow$ obter\_tempo\_segundos()\;
			vibracao $\leftarrow$ amplitude $\times$ seno(2 $\times$ 3.14159 $\times$ FREQ\_VIB $\times$ tempo)\;
			pwm\_atual $\leftarrow$ pwm\_atual + vibracao\;
		}
	}
\end{algorithm}

\subsection{Calibração Automática}\label{subsec:calibracao-automatica}

Ajuste automático dos ganhos baseado na atividade detectada. A calibração adaptativa monitora atividade média e ajusta ganhos automaticamente para manter resposta adequada:

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:calibracao-auto}Calibração automática}
	\Entrada{media\_atividade}
	\Saida{GANHO ajustado}
	\Inicio{
		GANHO $\leftarrow$ 80\;
		// Análise da atividade média\;
		\Se{media\_atividade > 0.5}{
			GANHO $\leftarrow$ GANHO $\times$ 0.8\;
			escreva("Reduzindo sensibilidade")\;
		}
		\SenaoSe{media\_atividade < 0.1}{
			GANHO $\leftarrow$ GANHO $\times$ 1.2\;
			escreva("Aumentando sensibilidade")\;
		}
	}
\end{algorithm}

\section{Implementação da Interface Gráfica}\label{sec:interface-grafica}

O Python foi escolhido devido à facilidade de criação de software e à possibilidade de usar o tkinter para a interface, permitindo uma futura aplicação para outros sistemas operacionais, caso necessário. A visualização de vídeo será feita utilizando as próprias bibliotecas do Python nativas e exibida em tempo real de acordo com os frames recebidos pelo carrinho. Podemos utilizar um meio parecido ao do artigo de \citeonline{shendge2023development}, que desenvolveram streaming de vídeo ao vivo utilizando Raspberry Pi com câmera USB, obtendo latência de 1--3 segundos na transmissão com taxa de 10 quadros por segundo na resolução de $640\times480$, demonstrando a viabilidade técnica do streaming em tempo real com essa plataforma para streaming de vídeo em tempo real com Raspberry Pi.

\subsection{Especificação dos Dados Transmitidos}\label{subsec:dados-transmitidos}

A \autoref{tab:dados-transmitidos} apresenta os tipos de dados, direção de transmissão, frequência e formato utilizados na comunicação entre os componentes do sistema.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:dados-transmitidos} Especificação dos dados transmitidos no sistema}
\IBGEtab{}{%
	\begin{tabular}{p{4cm}p{3cm}p{3.5cm}p{3.5cm}}
		\toprule
		Tipo de Dado & Direção & Frequência de transmissão & Formato \\
		\midrule \midrule
		Comandos de controle (direção, velocidade, freio) & PC $\rightarrow$ Carrinho & 1000 Hz (1ms) & JSON \\
		\midrule
		Stream de vídeo da câmera OV5647 & Carrinho $\rightarrow$ PC & 30 FPS & H.264 comprimido via UDP \\
		\midrule
		Dados do sensor BMI160 (accel\_x, accel\_y, accel\_z) & Carrinho $\rightarrow$ PC & 1000 Hz (1ms) & JSON \\
		\midrule
		Dados do sensor BMI160 (gyro\_x, gyro\_y, gyro\_z) & Carrinho $\rightarrow$ PC & 1000 Hz (1ms) & JSON \\
		\midrule
		Posição do volante e pedais & Arduino $\rightarrow$ PC & 1000 Hz (1ms) & Serial \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

\section{Métricas de Validação}\label{sec:metricas-validacao}

O sistema será validado através das seguintes métricas específicas para garantir o atendimento aos requisitos funcionais e de performance: latência média, jitter, packet loss, throughput de dados, FPS médio, estabilidade de transmissão, resolução efetiva, precisão de detecção de eventos, tempo de resposta PWM, realismo subjetivo, utilização CPU/RAM, temperatura operacional, estabilidade geral, precisão de calibração, drift térmico e taxa de amostragem efetiva.

\subsection{Análise de Poder Estatístico}\label{subsec:poder-estatistico}

Para garantir a robustez estatística dos resultados obtidos, foi realizada análise de poder estatístico baseada na metodologia proposta por Cohen (1988). O cálculo do tamanho da amostra necessário considerou os seguintes parâmetros: n = 90.000 pontos de telemetria coletados durante 15 minutos de operação contínua, superando significativamente o mínimo requerido de 384 amostras para população infinita com 95\% de confiança e margem de erro de 5\%, poder estatístico (1-$ \beta $) = 0.80, garantindo 80\% de probabilidade de detectar diferenças significativas quando elas realmente existem, conforme recomendado para pesquisas em engenharia, nível de significância $ \alpha $ = 0.05, estabelecendo 5\% de probabilidade de erro tipo I (rejeitar hipótese nula verdadeira), e effect size d = 0.5 (tamanho do efeito médio) para comparações entre sistema proposto e benchmarks do estado da arte, permitindo detectar melhorias práticas significativas.

A análise demonstra que o tamanho da amostra coletada (n = 90.000) proporciona poder estatístico superior a 99\% para detectar diferenças com effect size $ \geq $ 0.2, validando estatisticamente as comparações realizadas com o estado da arte apresentadas nos resultados.

\section{Etapas de Desenvolvimento}\label{sec:etapas-desenvolvimento}

As etapas de desenvolvimento seguem respectivamente:

\begin{alineascomnumero}
	\item Modelagem, impressão e montagem do chassi do carrinho;
	\item Testes de desempenho e comunicação entre o Raspberry Pi e o Cliente (PC);
	\item Integração gradual dos sensores e atuadores do carrinho com o Raspberry Pi;
	\item Testes de comunicação do carrinho completo entre o PC\@;
	\item Modelagem, impressão e montagem do cockpit;
	\item Teste de atuadores e sensores de comando da direção e pedais para o PC via serial;
	\item Integração gradual do cockpit com o PC via serial;
	\item Teste completo entre o carrinho e o cockpit.
\end{alineascomnumero}

\section{Controle de Motores}\label{sec:controle-motores}

Os motores serão controlados pela ponte H, que permite adaptar o RPM deles de acordo com um conta-giros de um carro de corrida, possibilitando fazer a troca de marchas de acordo com um cálculo próprio para simular um carro real. A performance de controladores DC se tornou viável, assim como trata o artigo de \citeonline{manuel2023control}, que analisaram o desempenho de diferentes algoritmos meta-heurísticos no ajuste de controladores PID para controle de velocidade de motores DC, mostrando que o TLBO apresentou a maior velocidade de convergência e que controladores de lógica fuzzy superaram os PIDs otimizados em termos de qualidade de resposta.

\section{Armazenamento de Logs e Validação}\label{sec:logs-validacao}

Serão armazenados logs no PC (cliente) para validação das telemetrias entre corridas e assim analisar como na Fórmula 1 atual, usando bibliotecas do Python próprias para isso. Esses logs também serão úteis para analisar os sensores e assim melhorar a adaptabilidade do simulador para situações cada vez mais reais de corridas.

\section{Limitações e Considerações de Alcance}\label{sec:limitacoes-alcance}

O alcance da rede WiFi é limitado ao range do roteador; porém, o uso de redes mesh torna possível a criação do projeto em escala 1:8 devido ao tamanho de pistas de corridas reais que não passarão de 600 metros de distância. Assim, um local aberto possibilita a criação de simuladores em tempo real, e também o uso de conexão 5G possibilita a melhoria de maior redução de latência.

% TODO: Adicionar figura da arquitetura do sistema
% A \autoref{fig:arquitetura-sistema} apresenta a arquitetura geral do sistema proposto, mostrando a comunicação entre o carrinho, o cliente PC e o cockpit através do protocolo UDP.
% \begin{figure}[h!]
%     \captionsetup{width=16cm}
%     \Caption{\label{fig:arquitetura-sistema} Diagrama da arquitetura do sistema de controle remoto com force feedback}
%     \UFCfig{}{
%         \includegraphics[width=16cm]{figuras/arquitetura-sistema}
%     }{
%         \Fonte{elaborado pelo autor.}
%     }
% \end{figure}

\section{Reprodutibilidade e Transparência Experimental}\label{sec:reprodutibilidade-transparencia}

A garantia de reprodutibilidade científica constitui um pilar fundamental para a validação e evolução do conhecimento em engenharia de sistemas embarcados. Seguindo as diretrizes estabelecidas por \citeonline{graf2024monitoring} para avaliação de desempenho de sistemas wireless, este trabalho adota protocolos rigorosos de documentação e disponibilização de recursos para permitir a replicação completa dos experimentos realizados.

\subsection{Disponibilização de Código Fonte e Datasets}\label{subsec:codigo-datasets}

Todo o código fonte desenvolvido para este projeto será disponibilizado publicamente sob licença MIT, incluindo os scripts de controle do Raspberry Pi 4, algoritmos de force feedback implementados no Arduino Mega, interface gráfica em Python/Tkinter e rotinas de análise estatística dos dados coletados. Conforme demonstrado por \citeonline{bobrovsky2023development}, a transparência no desenvolvimento de sistemas embarcados facilita a reprodução e melhoria contínua das soluções propostas.

Os datasets coletados durante as sessões experimentais, totalizando mais de 90.000 pontos de telemetria e 26.925 frames de vídeo, serão disponibilizados em formato estruturado JSON e CSV, acompanhados de metadados descritivos. Cada arquivo de dataset incluirá timestamps precisos em formato ISO 8601, identificadores únicos de sessão, condições experimentais documentadas e checksums MD5 para verificação de integridade. A estrutura de dados segue o padrão FAIR (Findable, Accessible, Interoperable, Reusable), garantindo máxima reutilização pelos pesquisadores.

\subsection{Protocolo Detalhado de Replicação}\label{subsec:protocolo-replicacao}

O protocolo de replicação experimental documentado contempla todos os aspectos críticos para reprodução fidedigna dos resultados obtidos. As especificações de hardware incluem números de modelo exatos, versões de firmware e configurações específicas de cada componente utilizado no sistema. Para o Raspberry Pi 4, documenta-se a versão do Raspberry Pi OS (Bullseye 64-bit), kernel utilizado (5.15.84-v8+) e configurações específicas do arquivo config.txt para otimização da câmera OV5647.

As configurações de rede wireless seguem padrões reproduzíveis, especificando canal WiFi (2.4GHz canal 6), potência de transmissão (20dBm), tipo de roteador utilizado (TP-Link Archer C6) e posicionamento físico dos equipamentos. As condições ambientais durante os experimentos são registradas detalhadamente, incluindo temperatura ambiente (22±2°C), umidade relativa (45±5\%), interferências eletromagnéticas medidas e layout físico do ambiente de teste.

\subsection{Documentação de Configurações Ambientais}\label{subsec:configuracoes-ambientais}

As configurações ambientais experimentais são registradas sistematicamente para garantir reprodutibilidade das condições de teste. O ambiente de rede é caracterizado através de medições de potência de sinal WiFi utilizando ferramentas como iwconfig e wavemon, documentando valores de RSSI (Received Signal Strength Indicator) em múltiplos pontos do ambiente experimental.

As características do ambiente físico incluem dimensões precisas do local de teste (5m × 8m), materiais de construção das paredes (alvenaria com reboco), presença de obstáculos metálicos e fontes potenciais de interferência eletromagnética. O posicionamento relativo entre carrinho e estação de controle é documentado com coordenadas precisas, utilizando sistema de referência baseado em marcos físicos permanentes.

As condições de iluminação para os testes de câmera são padronizadas utilizando iluminação artificial controlada (lâmpadas LED 6500K, 1000 lúmens), minimizando variações devido à iluminação natural. Os padrões de teste visual incluem alvos de calibração com dimensões conhecidas, permitindo validação da qualidade de captura de vídeo independente das condições específicas do ambiente.

O controle de temperatura ambiente utiliza sistema de climatização para manter estabilidade térmica durante as sessões experimentais, evitando drift térmico excessivo nos sensores. Registros contínuos de temperatura e umidade são mantidos através de datalogger dedicado, correlacionando variações ambientais com performance do sistema.