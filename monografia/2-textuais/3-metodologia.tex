\chapter{Metodologia}
\label{chap:metodologia}

Será realizado um desenvolvimento incremental e modular de um simulador completo de um carrinho de Fórmula 1 com cockpit, sendo o carrinho controlado via protocolo UDP. Utilizarei uma metodologia de prototipagem evolutiva, que busca o teste individual de cada componente antes da integração final. O projeto busca um objetivo semelhante ao artigo de \citeonline{shaik2025design}, conforme apresentado na fundamentação teórica.

O projeto seguirá uma arquitetura de três camadas: o carrinho com o elemento principal sendo o Raspberry Pi 4 terá o objetivo de receber mensagens de controle e enviar mensagens de vídeo e status de sensores; a comunicação entre o carrinho e o cliente será feita por protocolo UDP\@; e, por último, o PC (cliente) receberá as mensagens e encaminhará os comandos de status para o simulador, bem como encaminhará as mensagens de controle para o carrinho. A integração de múltiplos sensores segue a abordagem de \citeonline{bobrovsky2023development}, visando um bom resultado de feedback ao usuário.

\section{Especificações dos Componentes}
\label{sec:especificacoes}

A \autoref{tab:componentes} apresenta as especificações detalhadas dos componentes utilizados no sistema, definindo suas funções específicas na arquitetura do projeto.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:componentes} Especificações dos componentes utilizados no sistema}
\IBGEtab{}{%
	\begin{tabular}{p{3.5cm}p{6cm}p{6cm}}
		\toprule
		Componente & Especificação & Função no Sistema \\
		\midrule \midrule
		Raspberry Pi 4 Model B & Broadcom BCM2711, Quad core Cortex-A72 64-bit @ 1.8GHz, 8GB RAM & Núcleo de controle e comunicação do carrinho, servidor UDP, processamento de vídeo e controle de sensores \\
		\midrule
		ESP32 DevKit V1 & Dual-core Xtensa LX6 @ 240MHz, 520KB SRAM, 4MB Flash, WiFi/Bluetooth & Controle de encoders do cockpit, force feedback via BTS7960 e comunicação serial USB com cliente PC \\
		\midrule
		Câmera OV5647 & 5MP, 2592×1944 pixels, vídeo 1080p/30fps, interface CSI & Captura de vídeo em tempo real para transmissão via UDP \\
		\midrule
		Sensor BMI160 & IMU 6 eixos, ±4g/±500°/s, 16 bits, I2C, 100Hz sampling & Detecção de forças G, aceleração e velocidade angular para force feedback \\
		\midrule
		Motor RC 775 & 24V, 12.000 RPM, com transmissão manual de 5 marchas & Propulsão principal do carrinho com zonas de eficiência F1 \\
		\midrule
		Motor DC 775 & 24V, 12.000 RPM, controlado por BTS7960 & Geração de force feedback no volante do cockpit via ESP32 \\
		\midrule
		Ponte H BTS7960 & 5.5--27Vdc, corrente contínua 40A, proteção térmica integrada & Controle bidirecional de velocidade dos motores DC \\
		\midrule
		Servo MG996R & 4.8--7.2V, torque 11kg.cm, rotação 180°, velocidade 0.14s/60° & Controle de direção e sistema de freio do carrinho \\
		\midrule
		Caixa Diferencial HSP 1:10 & Modelo 94111/94123, relação 02051 & Transmissão diferencial para rodas traseiras do carrinho \\
		\midrule
		Amortecedores RC 1:10 & Compatível Axial SCX10/TRX4, óleo ajustável & Suspensão do carrinho e amortecimento dos pedais do cockpit \\
		\midrule
		Atuadores Lineares DC & 12V, força 1000N, curso 250mm, velocidade 14mm/s & Simulação de movimentos da pista e força G no cockpit \\
		\midrule
		Rolamento Unidirecional CSK8PP & $8\times22\times9$mm, uma direção de rotação & Proteção contra travamento por torque reverso no eixo de velocidade \\
		\midrule
		Encoder LPD3806-600BM & 600 PPR, saída A/B quadratura, 5--24V & Leitura de posição de acelerador, freio e direção no cockpit (3 unidades) \\
		\midrule
		PCA9685 PWM Driver & 16 canais, 12 bits, I2C, endereço \texttt{0x40} & Controle de servos (freio dianteiro, traseiro e direção) \\
		\midrule
		ADS1115 ADC & 16 bits, 4 canais, I2C, endereço \texttt{0x48} & Monitoramento de corrente via sensores ACS758 \\
		\midrule
		INA219 & Sensor corrente/tensão, I2C, endereço \texttt{0x41} & Monitoramento de energia do Raspberry Pi \\
		\midrule
		Sensor DS18B20 & Digital 1-Wire, $-55$°C a $+125$°C, precisão $\pm0{,}5$°C & Monitoramento de temperatura do motor e eletrônica \\
		\midrule
		ACS758 100A & Sensor Hall, sensibilidade 20mV/A, largura de banda 120kHz & Medição de corrente do motor DC 775 via ADS1115 \\
		\midrule
		ACS758 50A & Sensor Hall, sensibilidade 40mV/A, largura de banda 120kHz & Medição de corrente do Raspberry Pi e servos via ADS1115 \\
		\midrule
		Regulador XL4015 & Step-down 8--36V para 1.25--32V, 5A, eficiência 96\% & Alimentação 5V do Raspberry Pi a partir da bateria \\
		\midrule
		UBEC 15A & 6--12S entrada, 5.25V saída, 15A contínuo, 30A pico & Alimentação dos servos MG996R \\
		\midrule
		Bateria LiPo 3S & Turnigy Graphene 6000mAh, 11.1V, 75C descarga & Fonte de energia principal do veículo \\
		\midrule
		Chassi FV01 & Escala 1:5 (modificada), impressão 3D em PLA, pneus de borracha & Estrutura do veículo com suspensão push rod e aerodinâmica funcional \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

\section{Protocolo de Comunicação UDP}
\label{sec:protocolo-udp}

O UDP é um protocolo que lida com o alto envio de mensagens, muito utilizado para envio de streams e em jogos de computador. A arquitetura atual necessita de baixa latência, pois uma latência muito alta irá atrapalhar o controle em tempo real do carrinho, passando por um alto delay de comandos e prejudicando a experiência do usuário. Conforme demonstrado por \citeonline{lu2023udprt} na fundamentação teórica, protocolos baseados em UDP alcançam latências significativamente inferiores ao TCP em aplicações de tempo real, justificando o uso desse protocolo.

\subsection{Evolução das Decisões de Arquitetura de Comunicação}
\label{subsec:evolucao-decisoes-comunicacao}

A arquitetura final de comunicação do sistema foi definida após uma série de testes experimentais com diferentes tecnologias e topologias de rede. O objetivo inicial era verificar a viabilidade de controlar múltiplos carrinhos simultaneamente através de um servidor central que redirecionaria mensagens entre clientes e veículos. A meta de latência estabelecida foi de no máximo 10ms para comunicação em tempo real na mesma rede local.

\subsubsection{Testes com Arduino Mega e ESP8266}

A primeira configuração testada utilizou um Arduino Mega com módulo ESP8266 como controlador do veículo, comunicando-se via WiFi com um Raspberry Pi 4 (servidor) e um notebook (cliente). Os resultados demonstraram latência média de 60ms, valor considerado inadequado para controle em tempo real. A análise identificou o módulo ESP8266 como gargalo do sistema: mesmo com o Raspberry Pi enviando mensagens a cada 1ms, o ESP8266 não conseguia processar adequadamente devido à necessidade de alternar entre modos de leitura e escrita para processar e transmitir mensagens.

\subsubsection{Testes com ESP32}

Para melhorar o processamento, o Arduino Mega com ESP8266 foi substituído por um ESP32 DevKit V1, que possui processador dual-core mais potente apesar de menor quantidade de pinos GPIO. A latência reduziu para 40ms, representando melhoria de 33\% em relação à configuração anterior. Entretanto, esse valor ainda não atendia à meta de 10ms, considerando que a comunicação UDP entre servidor e cliente adicionaria latência adicional em cenários com servidores geograficamente distribuídos.

\subsubsection{Testes com Módulo NRF24L01}

Buscando comunicação mais rápida entre servidor e veículo, foram realizados testes com módulos de rádio NRF24L01 com antena externa, capazes de alcançar até 800 metros com boa qualidade de sinal. Os resultados foram expressivos: latência de apenas 2ms entre os dispositivos. Porém, essa abordagem implica comunicação direta ponto-a-ponto entre servidor e veículo, aumentando a complexidade para adicionar novos carrinhos ao sistema.

\subsubsection{Avaliação de Redes Mesh}

Para estender o alcance além dos 800 metros do NRF24L01, foi avaliada a implementação de rede mesh. A análise indicou acréscimo de aproximadamente 2ms de latência para cada salto entre antenas intermediárias, além de introduzir erros na resposta de status do veículo. Uma otimização testada foi utilizar formato ACK para retorno de status dos sensores, eliminando a alternância entre leitura e escrita. Contudo, essa abordagem tornou a implementação de mesh com NRF24L01 excessivamente complexa para o cronograma disponível.

O protocolo ESP-NOW foi considerado como alternativa para comunicação mesh entre dispositivos ESP32, porém foi descartado devido ao alcance limitado de aproximadamente 50 metros --- significativamente inferior aos 800 metros do NRF24L01 com antena externa --- além do custo mais elevado por unidade.

\subsubsection{Decisão Final: Arquitetura UDP com Raspberry Pi e ESP32}

A análise comparativa dos testes, sumarizada na \autoref{tab:comparativo-comunicacao}, conduziu à definição da arquitetura final baseada em três pilares: protocolo UDP, Raspberry Pi 4 embarcado no veículo e ESP32 no cockpit. O princípio norteador foi manter o sistema simples e funcional.

A comunicação via rádio NRF24L01, apesar de apresentar excelente latência (2ms) e alcance (800m), exigiria a implementação de um broker intermediário para traduzir os pacotes de rádio para o protocolo UDP do servidor. Essa camada adicional aumentaria a complexidade do sistema, introduziria novos pontos de falha e demandaria desenvolvimento de firmware específico para gerenciamento da comunicação bidirecional entre rádio e rede IP.

A decisão de embarcar o Raspberry Pi 4 diretamente no veículo eliminou essa necessidade, permitindo comunicação UDP nativa com latência de apenas 1ms --- superando a meta estabelecida de 10ms. O Raspberry Pi atua simultaneamente como controlador do veículo e servidor UDP, processando vídeo da câmera OV5647, dados do sensor BMI160 e comandos de controle em uma única plataforma.

Para o cockpit, o ESP32 DevKit V1 foi mantido devido ao seu processamento superior em relação ao Arduino Mega, com dual-core de 240MHz contra single-core de 16MHz. Essa capacidade permite leitura simultânea de três encoders rotacionais a 100Hz, processamento de comandos de force feedback e comunicação serial USB com o cliente PC sem perda de dados. A comunicação serial USB entre ESP32 e cliente elimina a necessidade de protocolos wireless adicionais no cockpit, garantindo conexão estável e determinística.

Essa arquitetura resultou em um sistema com apenas dois saltos de comunicação (Veículo $\leftrightarrow$ Cliente $\leftrightarrow$ Cockpit), maximizando a confiabilidade e minimizando a latência total do loop de controle.

\begin{table}[!h]
\captionsetup{width=16cm}
\Caption{\label{tab:comparativo-comunicacao} Comparativo de latência entre tecnologias de comunicação testadas}
\IBGEtab{}{%
	\begin{tabular}{p{5cm}p{3cm}p{3cm}p{4cm}}
		\toprule
		Configuração & Latência Média & Alcance & Observações \\
		\midrule \midrule
		Arduino Mega + ESP8266 & 60ms & WiFi local & Gargalo no ESP8266 \\
		\midrule
		ESP32 DevKit V1 & 40ms & WiFi local & Melhoria de 33\% \\
		\midrule
		NRF24L01 + antena & 2ms & 800m & Comunicação ponto-a-ponto \\
		\midrule
		NRF24L01 mesh & 2ms + 2ms/salto & Extensível & Complexidade elevada \\
		\midrule
		ESP-NOW (ESP32) & Similar ao WiFi & 50m & Custo elevado, alcance limitado \\
		\midrule
		\textbf{RPi 4 embarcado + UDP} & \textbf{1ms} & \textbf{WiFi local} & \textbf{Solução adotada} \\
		\bottomrule
	\end{tabular}%
}{%
\Fonte{elaborado pelo autor.}%
}
\end{table}

\subsection{Justificativa para UDP Simples}
\label{subsec:justificativa-udp}

A escolha do UDP simples sobre protocolos mais avançados como UDP-RT \citeonline{lu2023udprt} é justificada pela necessidade de simplicidade de implementação e recursos limitados do Raspberry Pi 4. Embora o UDP-RT ofereça vantagens em redes congestionadas, sua implementação requer mecanismos adicionais de correção de erros e detecção na camada de aplicação, aumentando significativamente a complexidade do sistema. Conforme demonstrado nos resultados, a latência obtida de 1,94ms com UDP simples supera os targets típicos de 5ms, validando que esta abordagem é adequada para o projeto.

% ============================================================================
% ARQUITETURA DO VEÍCULO (RASPBERRY PI 4)
% ============================================================================
\section{Arquitetura do Veículo (Raspberry Pi 4)}
\label{sec:arquitetura-veiculo}

O Raspberry Pi 4 Model B com 8GB de RAM constitui o núcleo de processamento embarcado no veículo, responsável por todas as operações de controle, sensoriamento e comunicação. A escolha deste hardware foi motivada pela capacidade de processamento suficiente para codificação de vídeo H.264 em tempo real, comunicação UDP nativa e controle de múltiplos periféricos via I2C, conforme validado nos testes de arquitetura descritos na \autoref{subsec:evolucao-decisoes-comunicacao}.

\subsection{Chassi e Estrutura}
\label{subsec:chassi-estrutura-veiculo}

O veículo utiliza o chassi FV01, um modelo de carro de Fórmula 1 projetado para impressão 3D por Velocity Projects\footnote{Modelo FV01 disponível em: \url{https://cults3d.com/en/3d-model/game/fv01-the-most-advanced-3d-printed-rc-racing-car-velocityprojects3d}. Créditos: VelocityProjects3D.}. O modelo original possui escala 1:7, porém foi modificado para escala 1:5 neste projeto para acomodar todos os componentes eletrônicos necessários. O modelo apresenta características avançadas que o tornam adequado para o projeto de teleoperação com feedback háptico:

O modelo inclui suspensão push rod independente que reproduz fielmente o comportamento de suspensões de carros de F1 reais, permitindo detecção precisa de forças G pelo sensor BMI160. A aerodinâmica funcional com asas dianteira e traseira gera downforce em velocidades elevadas, contribuindo para estabilidade e realismo. O diferencial operacional permite comportamento realista em curvas, essencial para geração de feedback háptico adequado. A modularidade do projeto, com peças projetadas para fácil reparo e substituição, facilita manutenção e modificações.

O chassi foi impresso em PLA utilizando impressora 3D, com pneus de borracha para melhor aderência e realismo. A modificação para escala 1:5 resultou em um veículo de maior porte comparado ao modelo original, proporcionando espaço interno adequado para acomodação do Raspberry Pi 4, sensores, drivers e demais componentes eletrônicos do sistema de teleoperação.

\subsection{Sistema de Sensoriamento}
\label{subsec:sensoriamento-veiculo}

O veículo incorpora múltiplos sensores para captura de dados em tempo real, transmitidos ao cliente via UDP para processamento e geração de feedback háptico.

\subsubsection{Câmera OV5647}

A câmera OV5647 conectada via interface CSI captura vídeo em resolução 1080p a 30 FPS. O stream de vídeo é codificado em H.264 diretamente pelo hardware do Raspberry Pi, minimizando uso de CPU e garantindo baixa latência. Os frames codificados são transmitidos via UDP para o cliente, onde são decodificados utilizando a biblioteca PyAV (wrapper do FFmpeg).

\subsubsection{Sensor IMU BMI160}

O sensor inercial BMI160 conectado via barramento I2C (endereço \texttt{0x68}) fornece dados de aceleração (3 eixos) e velocidade angular (3 eixos) a 100Hz. A configuração utiliza faixa de $\pm$4g para acelerômetro e $\pm$500°/s para giroscópio, adequadas para captura de forças G em manobras típicas de veículos RC. Os dados são transmitidos ao cliente em formato JSON via UDP, onde são processados para cálculo de force feedback e estimativa de velocidade.

\subsubsection{Monitoramento de Energia}

O sistema de monitoramento de energia utiliza sensores ACS758 (50A e 100A) conectados ao ADC ADS1115 (endereço \texttt{0x48}) para medição de corrente, e sensor INA219 (endereço \texttt{0x41}) para monitoramento de tensão e corrente do Raspberry Pi. Esses dados permitem análise de consumo energético e detecção de anomalias durante operação.

\subsection{Controle de Propulsão e Direção}
\label{subsec:propulsao-direcao-veiculo}

O sistema de propulsão utiliza motor RC 775 de 24V controlado por ponte H BTS7960, enquanto direção e freios são acionados por servos MG996R através do driver PWM PCA9685 (endereço \texttt{0x40}).

\subsubsection{Motor de Propulsão}

O motor RC 775 opera com transmissão manual de 5 marchas, simulando comportamento de veículo real. O controle de velocidade é realizado via PWM, com o BTS7960 permitindo operação bidirecional (frente/ré). O algoritmo de controle ajusta o fator de torque conforme a marcha selecionada:

\begin{equation}
\label{eq:fator-torque}
Fator_{torque} = 1.0 + 0.2 \times (Marcha_{max} - Marcha_{atual})
\end{equation}

\subsubsection{Sistema de Direção e Freios}

A direção utiliza servo MG996R no canal 2 do PCA9685, com rotação de 0° a 180°. O sistema de freio emprega dois servos MG996R (canais 0 e 1) para controle independente de freio dianteiro e traseiro, permitindo ajuste de balanceamento de frenagem. O balanceamento padrão é 60\% dianteiro e 40\% traseiro, ajustável via comandos do cliente.

\subsection{Proteção contra Força Eletromotriz de Retorno}
\label{subsec:protecao-backemf-veiculo}

Quando um motor DC gira --- seja por acionamento elétrico ou por força mecânica externa --- ele atua como gerador e produz uma tensão conhecida como força eletromotriz de retorno (\textit{back-EMF}). No contexto deste projeto, essa situação ocorre quando as rodas do veículo giram livremente (motor desligado) ou durante frenagem regenerativa.

O driver BTS7960 foi selecionado especificamente por possuir proteções integradas contra esse fenômeno. O circuito integrado incorpora diodos de \textit{freewheeling} nos MOSFETs de potência, que conduzem a corrente reversa de forma segura quando o motor opera como gerador. Além disso, o BTS7960 oferece proteção contra sobrecorrente, proteção térmica com desligamento automático em temperaturas elevadas e proteção contra curto-circuito, conforme especificado no datasheet do fabricante.

Essa arquitetura de proteção elimina a necessidade de componentes externos de proteção, como diodos flyback ou capacitores de supressão de transientes, simplificando o projeto eletrônico e aumentando a confiabilidade do sistema.

% ============================================================================
% ARQUITETURA DO COCKPIT (ESP32)
% ============================================================================
\section{Arquitetura do Cockpit (ESP32)}
\label{sec:arquitetura-cockpit}

O ESP32 DevKit V1 com processador dual-core Xtensa LX6 a 240MHz constitui o controlador do cockpit, responsável pela leitura de encoders, controle do motor de force feedback e comunicação serial com o cliente PC. A escolha do ESP32 sobre o Arduino Mega foi motivada pelo processamento superior, conforme demonstrado nos testes de latência da \autoref{subsec:evolucao-decisoes-comunicacao}.

\subsection{Leitura de Encoders Rotacionais}
\label{subsec:encoders-cockpit}

O cockpit utiliza três encoders rotacionais LPD3806-600BM-G5-24C com resolução de 600 pulsos por revolução (PPR) e saída em quadratura (canais A e B). A leitura é realizada via interrupções de hardware nos pinos GPIO, garantindo captura precisa mesmo em rotações rápidas.

O encoder de acelerador utiliza GPIO 25 (CLK) e GPIO 26 (DT) com pinos invertidos para correção de direção. O encoder de freio utiliza GPIO 27 (CLK) e GPIO 14 (DT). O encoder de direção utiliza GPIO 12 (CLK) e GPIO 13 (DT), também com pinos invertidos para correção de direção.

Os valores dos encoders são normalizados para porcentagem (0--100\% para acelerador e freio) ou ângulo (-100\% a +100\% para direção) e transmitidos ao cliente a 100Hz via serial USB.

\subsection{Controle de Marchas}
\label{subsec:marchas-cockpit}

O sistema de marchas utiliza dois botões push conectados aos GPIO 32 (subir marcha) e GPIO 33 (descer marcha). A detecção é feita por polling com debounce de software, evitando acionamentos múltiplos. Eventos de troca de marcha são transmitidos ao cliente como mensagens \texttt{GEAR\_UP} e \texttt{GEAR\_DOWN}.

\subsection{Sistema de Force Feedback}
\label{subsec:ff-cockpit}

O motor DC 775 de 24V do volante é controlado por ponte H BTS7960, recebendo comandos de intensidade e direção do cliente PC via serial USB. O protocolo de comunicação utiliza formato texto:

\begin{verbatim}
FF_MOTOR:ESQUERDA:45    - 45% de força anti-horária
FF_MOTOR:DIREITA:80     - 80% de força horária
FF_MOTOR:NEUTRO:0       - Libera o volante
\end{verbatim}

A proteção contra back-EMF do BTS7960, descrita na \autoref{subsec:protecao-backemf-veiculo}, também se aplica ao motor de force feedback, permitindo que o operador gire o volante livremente quando o motor não está acionado.

\subsection{Calibração de Encoders}
\label{subsec:calibracao-cockpit}

O sistema de calibração permite ajuste dos valores mínimo, máximo e centro de cada encoder, armazenados na EEPROM do ESP32. O protocolo de calibração opera via serial:

\begin{enumerate}
	\item Cliente envia \texttt{CAL\_START:THROTTLE/BRAKE/STEERING}
	\item ESP32 transmite valores brutos a 100Hz: \texttt{CAL\_THROTTLE:<valor>}
	\item Operador move o controle para posições extremas
	\item Cliente envia valores calibrados: \texttt{CAL\_SAVE:THROTTLE:min:max}
	\item ESP32 confirma: \texttt{CAL\_COMPLETE:THROTTLE}
\end{enumerate}

A estrutura de dados na EEPROM utiliza magic number (\texttt{0xCAFE}) e checksum para validação de integridade, com endereços separados para cada encoder (16 bytes cada).

\subsection{Comunicação Serial USB}
\label{subsec:serial-cockpit}

A comunicação com o cliente PC utiliza USB serial a 115200 baud, operando em modo full-duplex. O ESP32 transmite dados de encoders e eventos de marcha, enquanto recebe comandos de force feedback e calibração. A taxa de atualização de 100Hz (10ms) garante responsividade adequada para controle em tempo real.

% ============================================================================
% ARQUITETURA DO CLIENTE (PC)
% ============================================================================
\section{Arquitetura do Cliente (PC)}
\label{sec:arquitetura-cliente}

O cliente PC, implementado em Python com interface Tkinter, atua como hub central do sistema, recebendo dados do veículo via UDP, processando telemetria, calculando force feedback e transmitindo comandos para cockpit e veículo. O Python foi escolhido devido à facilidade de prototipagem e disponibilidade de bibliotecas para decodificação de vídeo (PyAV), interface gráfica (Tkinter) e comunicação (socket, pyserial).

\subsection{Interface Gráfica}
\label{subsec:interface-cliente}

A interface gráfica utiliza layout de duas colunas: telemetria à esquerda e vídeo/controles à direita. A viabilidade técnica do streaming em tempo real com Raspberry Pi foi demonstrada por \citeonline{shendge2023development}, conforme apresentado na fundamentação teórica.

O painel de instrumentos exibe RPM, marcha atual, posição do acelerador e velocidade estimada, atualizados em tempo real conforme dados recebidos do veículo e cockpit. A visualização de vídeo utiliza PyAV para decodificação H.264 e Pillow para renderização no canvas Tkinter.

\subsection{Recepção e Processamento de Dados}
\label{subsec:recepcao-cliente}

O cliente opera threads separadas para recepção UDP (veículo) e serial (cockpit), com filas thread-safe para transferência de dados à thread principal de interface. O filtro por IP garante que apenas pacotes do veículo configurado sejam processados, ignorando tráfego de rede não relacionado.

\subsection{Algoritmos de Cálculo de Force Feedback}
\label{subsec:algoritmos-ff-cliente}

Os algoritmos de force feedback são executados no cliente, utilizando dados do sensor BMI160 recebidos do veículo para calcular intensidade e direção da força a ser aplicada no volante.

Embora algoritmos meta-heurísticos como LHHO e TLBO demonstrem vantagens conforme \citeonline{ayinla2024optimal}, optou-se por implementação direta dos algoritmos de force feedback devido às limitações computacionais e à necessidade de resposta em tempo real inferior a 5ms.

\subsubsection{Cálculo das Forças G}

O algoritmo para cálculo das forças G considera os valores de aceleração linear e velocidade angular obtidos do sensor BMI160:

\begin{equation}
\label{eq:forca-g-frontal-cliente}
G_{frontal} = \frac{acelera\text{ç}\tilde{a}o_{linear\_X}}{9.81}
\end{equation}

\begin{equation}
\label{eq:forca-g-lateral-cliente}
G_{lateral} = \frac{velocidade_{angular\_Z} \times velocidade_{linear}}{9.81}
\end{equation}

\subsubsection{Algoritmos de Controle de Force Feedback}
\label{sec:algoritmos-force-feedback}

Serão acumulados vários dados sobre os sensores para analisar todos os valores e assim descobrir os padrões para controle háptico dos atuadores; dessa forma, posso calibrar de forma mais parecida possível com o ambiente real. O giroscópio me permite calcular tanto a aceleração do carro para os impulsos de força G lateral e frontal quanto calcular a posição do assoalho com relação à suspensão e emitir as vibrações do carro, como segue de exemplo no artigo de \citeonline{dreger2024evaluation}, que investigaram diferentes designs de feedback para orientação em sistemas controlados por humanos, demonstrando que feedback em tempo real pode melhorar significativamente a precisão do operador sobre diferentes designs de feedback para orientação.

O algoritmo para cálculo das forças G considera os valores de aceleração linear e velocidade angular obtidos do sensor BMI160, aplicando normalização por G para obter valores em força gravitacional:

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:calcular-forcas-g}Cálculo das forças G}
	\Entrada{accel\_x, gyro\_z, velocidade}
	\Saida{g\_frontal, g\_lateral}
	\Inicio{
		// Leitura dos sensores\;
		accel\_x $\leftarrow$ ler\_acelerometro\_x()\;
		gyro\_z $\leftarrow$ ler\_giroscopio\_z()\;
		// Cálculo das forças G\;
		g\_frontal $\leftarrow$ accel\_x / 9.81\;
		g\_lateral $\leftarrow$ (gyro\_z $\times$ velocidade) / 9.81\;
		// Limitação de segurança\;
		\Se{g\_frontal > 2.0}{g\_frontal $\leftarrow$ 2.0\;}
		\Se{g\_lateral > 1.5}{g\_lateral $\leftarrow$ 1.5\;}
	}
\end{algorithm}

\subsubsection{Detecção de Vibrações}

Inclinações são movimentos lentos; vibrações são variações rápidas no sinal. Filtros temporais são utilizados onde médias de janelas pequenas capturam inclinações, e diferenças entre amostras capturam vibrações:

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:detectar-vibracoes}Detecção de vibrações}
	\Entrada{buffer\_accel[10]}
	\Saida{media\_lenta, variacao\_rapida}
	\Inicio{
		// Calcular média (inclinação)\;
		media\_lenta $\leftarrow$ 0\;
		\Para{i de 0 até 9}{
			media\_lenta $\leftarrow$ media\_lenta + buffer\_accel[i]\;
		}
		media\_lenta $\leftarrow$ media\_lenta / 10\;
		// Calcular variação (vibração)\;
		variacao\_rapida $\leftarrow$ abs(buffer\_accel[9] - buffer\_accel[8])\;
		escreva("Inclinação: ", media\_lenta)\;
		escreva("Vibração: ", variacao\_rapida)\;
	}
\end{algorithm}

\subsubsection{Controle dos Atuadores}

O mapeamento linear multiplica força G por ganho e soma ao centro PWM (127) para posição neutra:

\begin{equation}
\label{eq:pwm-saida}
PWM_{saida} = PWM_{centro} + (For\text{ç}a_G \times Ganho_{calibra\text{ç}\tilde{a}o})
\end{equation}

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:controlar-atuadores}Controle dos atuadores}
	\Entrada{g\_frontal, g\_lateral}
	\Saida{pwm\_frontal, pwm\_lateral}
	\Inicio{
		PWM\_CENTRO $\leftarrow$ 127\;
		GANHO $\leftarrow$ 80\;
		// Conversão G para PWM\;
		pwm\_frontal $\leftarrow$ PWM\_CENTRO + (g\_frontal $\times$ GANHO)\;
		pwm\_lateral $\leftarrow$ PWM\_CENTRO + (g\_lateral $\times$ GANHO)\;
		// Limitação PWM (0--255)\;
		\Se{pwm\_frontal > 255}{pwm\_frontal $\leftarrow$ 255\;}
		\Se{pwm\_frontal < 0}{pwm\_frontal $\leftarrow$ 0\;}
		// Envio para atuadores\;
		enviar\_pwm\_atuador(pwm\_frontal)\;
	}
\end{algorithm}

\subsubsection{Suavização de Movimento}

Para evitar movimentos bruscos, aplica-se transição gradual implementando resposta de primeira ordem para transições graduais:

\begin{equation}
\label{eq:suavizacao}
PWM_{atual} = PWM_{atual} + (PWM_{target} - PWM_{atual}) \times Taxa_{suaviza\text{ç}\tilde{a}o}
\end{equation}

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:suavizar-movimento}Suavização de movimento}
	\Entrada{pwm\_target, pwm\_atual}
	\Saida{pwm\_atual atualizado}
	\Inicio{
		TAXA\_SUAVE $\leftarrow$ 0.3\;
		// Transição suave em direção ao valor target\;
		pwm\_atual $\leftarrow$ pwm\_atual + ((pwm\_target - pwm\_atual) $\times$ TAXA\_SUAVE)\;
		enviar\_pwm\_atuador(pwm\_atual)\;
	}
\end{algorithm}

\subsubsection{Geração de Vibrações}

Vibração senoidal modulada pela intensidade detectada gera vibrações realistas usando função seno com frequência típica de 25Hz:

\begin{equation}
\label{eq:vibracao}
Vibra\text{ç}\tilde{a}o = Amplitude \times \sin(2\pi \times Frequ\hat{e}ncia \times Tempo)
\end{equation}

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:gerar-vibracao}Geração de vibrações}
	\Entrada{intensidade}
	\Saida{vibracao aplicada}
	\Inicio{
		FREQ\_VIB $\leftarrow$ 25\;
		LIMIAR $\leftarrow$ 0.1\;
		\Se{intensidade > LIMIAR}{
			amplitude $\leftarrow$ intensidade $\times$ 200\;
			tempo $\leftarrow$ obter\_tempo\_segundos()\;
			vibracao $\leftarrow$ amplitude $\times$ seno(2 $\times$ 3.14159 $\times$ FREQ\_VIB $\times$ tempo)\;
			pwm\_atual $\leftarrow$ pwm\_atual + vibracao\;
		}
	}
\end{algorithm}

\subsubsection{Calibração Automática de Ganhos}

Ajuste automático dos ganhos baseado na atividade detectada. A calibração adaptativa monitora atividade média e ajusta ganhos automaticamente para manter resposta adequada:

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:calibracao-auto}Calibração automática}
	\Entrada{media\_atividade}
	\Saida{GANHO ajustado}
	\Inicio{
		GANHO $\leftarrow$ 80\;
		// Análise da atividade média\;
		\Se{media\_atividade > 0.5}{
			GANHO $\leftarrow$ GANHO $\times$ 0.8\;
			escreva("Reduzindo sensibilidade")\;
		}
		\SenaoSe{media\_atividade < 0.1}{
			GANHO $\leftarrow$ GANHO $\times$ 1.2\;
			escreva("Aumentando sensibilidade")\;
		}
	}
\end{algorithm}

\subsubsection{Algoritmo Completo de Force Feedback da Direção}

O sistema de force feedback da direção combina três componentes principais: força lateral (curvas), rotação yaw e mola de centralização. O algoritmo é executado no cliente PC e envia comandos para o motor DC 775 do cockpit via ESP32:

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:ff-direcao}Cálculo do force feedback da direção}
	\Entrada{g\_lateral, gyro\_z, angulo\_direcao, sensibilidade, friccao, filtro, damping}
	\Saida{intensidade\_ff, direcao\_ff}
	\Inicio{
		// Componente 1: Força lateral (curvas) - máximo 100\%\;
		componente\_lateral $\leftarrow$ minimo(abs(g\_lateral) $\times$ 50, 100)\;
		// Componente 2: Rotação yaw - máximo 50\%\;
		componente\_yaw $\leftarrow$ minimo(abs(gyro\_z) / 60.0 $\times$ 50, 50)\;
		// Componente 3: Mola de centralização - máximo 40\%\;
		razao\_angulo $\leftarrow$ abs(angulo\_direcao) / 100.0\;
		componente\_centragem $\leftarrow$ razao\_angulo $\times$ 40\;
		// Força base combinada (0-100\%)\;
		ff\_base $\leftarrow$ minimo(componente\_lateral + componente\_yaw + componente\_centragem, 100)\;
		// Aplica sensibilidade\;
		ff\_ajustado $\leftarrow$ ff\_base $\times$ sensibilidade\;
		// Aplica fricção baseada na rotação\;
		forca\_friccao $\leftarrow$ minimo(abs(gyro\_z) / 100.0, 1.0) $\times$ friccao $\times$ 30\;
		ff\_ajustado $\leftarrow$ minimo(ff\_ajustado + forca\_friccao, 100.0)\;
		// Aplica filtro (suavização exponencial)\;
		ff\_ajustado $\leftarrow$ ff\_ajustado $\times$ (1.0 - filtro) + ff\_filtrado\_anterior $\times$ filtro\;
		// Aplica damping (média móvel)\;
		intensidade\_ff $\leftarrow$ ff\_ajustado $\times$ (1.0 - damping) + ff\_anterior $\times$ damping\;
		// Determina direção do force feedback\;
		valor\_direcao $\leftarrow$ (-angulo\_direcao) + (g\_lateral $\times$ 10) + gyro\_z\;
		\Se{valor\_direcao > 5}{direcao\_ff $\leftarrow$ "DIREITA"\;}
		\SenaoSe{valor\_direcao < -5}{direcao\_ff $\leftarrow$ "ESQUERDA"\;}
		\Senao{direcao\_ff $\leftarrow$ "NEUTRO"\;}
	}
\end{algorithm}

\subsubsection{Cálculo de Velocidade por Integração}

A velocidade do veículo é estimada através da integração numérica da aceleração medida pelo sensor BMI160. Um fator de decaimento é aplicado para simular atrito e resistência do ar:

\begin{equation}
\label{eq:velocidade-integracao}
v(t) = v(t-1) + a \times \Delta t
\end{equation}

\begin{equation}
\label{eq:velocidade-decaimento}
v_{final} = v(t) \times fator_{decaimento}
\end{equation}

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:calcular-velocidade}Cálculo de velocidade por integração}
	\Entrada{accel\_x, accel\_y, tempo\_atual}
	\Saida{velocidade\_total\_kmh}
	\Inicio{
		LIMIAR\_ACCEL $\leftarrow$ 0.1\;
		FATOR\_DECAIMENTO $\leftarrow$ 0.995\;
		LIMIAR\_VELOCIDADE $\leftarrow$ 0.01\;
		// Calcula delta time\;
		dt $\leftarrow$ tempo\_atual - tempo\_anterior\;
		tempo\_anterior $\leftarrow$ tempo\_atual\;
		// Filtra ruído da aceleração\;
		\Se{abs(accel\_x) < LIMIAR\_ACCEL}{accel\_x $\leftarrow$ 0\;}
		\Se{abs(accel\_y) < LIMIAR\_ACCEL}{accel\_y $\leftarrow$ 0\;}
		// Integração: v = v0 + a $\times$ dt\;
		velocidade\_x $\leftarrow$ velocidade\_x + accel\_x $\times$ dt\;
		velocidade\_y $\leftarrow$ velocidade\_y + accel\_y $\times$ dt\;
		// Aplica decaimento (simula atrito)\;
		velocidade\_x $\leftarrow$ velocidade\_x $\times$ FATOR\_DECAIMENTO\;
		velocidade\_y $\leftarrow$ velocidade\_y $\times$ FATOR\_DECAIMENTO\;
		// Zera velocidades muito pequenas\;
		\Se{abs(velocidade\_x) < LIMIAR\_VELOCIDADE}{velocidade\_x $\leftarrow$ 0\;}
		\Se{abs(velocidade\_y) < LIMIAR\_VELOCIDADE}{velocidade\_y $\leftarrow$ 0\;}
		// Calcula magnitude e converte para km/h\;
		velocidade\_ms $\leftarrow$ raiz(velocidade\_x$^2$ + velocidade\_y$^2$)\;
		velocidade\_total\_kmh $\leftarrow$ velocidade\_ms $\times$ 3.6\;
	}
\end{algorithm}

\subsection{Sistema de Telemetria em Tempo Real}
\label{subsec:telemetria-cliente}

O sistema de telemetria exibe gráficos estilo Fórmula 1 em tempo real utilizando a biblioteca Matplotlib integrada ao Tkinter. Os dados são armazenados em buffers circulares (\textit{deque}) com capacidade máxima de 500 pontos, representando aproximadamente 50 segundos de histórico a 10Hz:

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:atualizar-telemetria}Atualização dos gráficos de telemetria}
	\Entrada{dados\_sensores}
	\Saida{graficos\_atualizados}
	\Inicio{
		MAX\_PONTOS $\leftarrow$ 500\;
		JANELA\_TEMPO $\leftarrow$ 30\;
		// Calcula tempo relativo desde o início\;
		tempo\_atual $\leftarrow$ tempo\_sistema() - tempo\_inicio\;
		// Adiciona dados aos buffers circulares\;
		buffer\_tempo.adicionar(tempo\_atual)\;
		buffer\_velocidade.adicionar(dados\_sensores["velocidade"])\;
		buffer\_acelerador.adicionar(dados\_sensores["acelerador"])\;
		buffer\_freio.adicionar(dados\_sensores["freio"])\;
		buffer\_g\_lateral.adicionar(dados\_sensores["g\_lateral"])\;
		buffer\_g\_frontal.adicionar(dados\_sensores["g\_frontal"])\;
		// Ajusta janela de visualização (últimos 30 segundos)\;
		x\_min $\leftarrow$ maximo(0, tempo\_atual - JANELA\_TEMPO)\;
		x\_max $\leftarrow$ tempo\_atual + 1\;
		// Atualiza linhas dos gráficos\;
		linha\_velocidade.atualizar(buffer\_tempo, buffer\_velocidade)\;
		linha\_acelerador.atualizar(buffer\_tempo, buffer\_acelerador)\;
		linha\_freio.atualizar(buffer\_tempo, buffer\_freio)\;
		linha\_g\_lateral.atualizar(buffer\_tempo, buffer\_g\_lateral)\;
		linha\_g\_frontal.atualizar(buffer\_tempo, buffer\_g\_frontal)\;
		// Redesenha canvas\;
		canvas.redesenhar()\;
	}
\end{algorithm}

\subsection{Sistema de Auto-Save e Exportação de Dados}
\label{subsec:autosave-cliente}

O sistema implementa salvamento automático periódico a cada 20 segundos, exportando logs, dados de sensores e telemetria em formato Pickle (binário Python), que oferece performance 5--10x superior ao CSV para serialização de estruturas de dados complexas:

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:auto-save}Auto-save periódico de dados}
	\Entrada{console, intervalo\_ms}
	\Saida{arquivos\_salvos}
	\Inicio{
		MIN\_LOGS $\leftarrow$ 10\;
		MIN\_SENSORES $\leftarrow$ 100\;
		MIN\_TELEMETRIA $\leftarrow$ 50\;
		DIRETORIO $\leftarrow$ "exports/auto/"\;
		// Verifica se há dados novos suficientes\;
		qtd\_logs $\leftarrow$ contar\_linhas(console.log\_text)\;
		qtd\_sensores $\leftarrow$ tamanho(sensor\_display.historico)\;
		qtd\_telemetria $\leftarrow$ tamanho(telemetria.buffer\_tempo)\;
		// Só salva se atingir mínimo E houver dados novos\;
		\Se{(qtd\_logs $\geq$ MIN\_LOGS) OU (qtd\_sensores $\geq$ MIN\_SENSORES) OU (qtd\_telemetria $\geq$ MIN\_TELEMETRIA)}{
			timestamp $\leftarrow$ formato\_data("YYYYMMDD\_HHMMSS")\;
			// Salva logs em texto\;
			\Se{qtd\_logs $\geq$ MIN\_LOGS}{
				salvar\_arquivo(DIRETORIO + "logs\_" + timestamp + ".txt", console.log\_text)\;
			}
			// Salva sensores em Pickle (binário)\;
			\Se{qtd\_sensores $\geq$ MIN\_SENSORES}{
				pickle.salvar(DIRETORIO + "sensors\_" + timestamp + ".pkl", sensor\_display.historico)\;
			}
			// Salva telemetria em Pickle\;
			\Se{qtd\_telemetria $\geq$ MIN\_TELEMETRIA}{
				pickle.salvar(DIRETORIO + "telemetry\_" + timestamp + ".pkl", telemetria.dados)\;
			}
			// Limpa buffers após salvar\;
			console.log\_text.limpar()\;
			sensor\_display.resetar()\;
			telemetria.resetar()\;
		}
		// Reagenda próximo auto-save\;
		agendar(intervalo\_ms, auto\_save)\;
	}
\end{algorithm}

A estrutura dos arquivos Pickle exportados permite fácil leitura posterior para análise:

\begin{verbatim}
import pickle
with open("sensors_20241216_143000.pkl", "rb") as f:
    dados = pickle.load(f)
# dados contém dicionário com listas de cada sensor
\end{verbatim}

\section{Métricas de Validação}
\label{sec:metricas-validacao}

O sistema será validado através das seguintes métricas específicas para garantir o atendimento aos requisitos funcionais e de performance: latência média, jitter, packet loss, throughput de dados, FPS médio, estabilidade de transmissão, resolução efetiva, precisão de detecção de eventos, tempo de resposta PWM, realismo subjetivo, utilização CPU/RAM, temperatura operacional, estabilidade geral, precisão de calibração, drift térmico e taxa de amostragem efetiva.

\subsection{Análise de Poder Estatístico}
\label{subsec:poder-estatistico}

Para garantir a robustez estatística dos resultados obtidos, foi realizada análise de poder estatístico baseada na metodologia proposta por Cohen (1988). O cálculo do tamanho da amostra necessário considerou os seguintes parâmetros: n = 90.000 pontos de telemetria coletados durante 15 minutos de operação contínua, superando significativamente o mínimo requerido de 384 amostras para população infinita com 95\% de confiança e margem de erro de 5\%, poder estatístico (1-$ \beta $) = 0.80, garantindo 80\% de probabilidade de detectar diferenças significativas quando elas realmente existem, conforme recomendado para pesquisas em engenharia, nível de significância $ \alpha $ = 0.05, estabelecendo 5\% de probabilidade de erro tipo I (rejeitar hipótese nula verdadeira), e effect size d = 0.5 (tamanho do efeito médio) para comparações entre sistema proposto e benchmarks do estado da arte, permitindo detectar melhorias práticas significativas.

A análise demonstra que o tamanho da amostra coletada (n = 90.000) proporciona poder estatístico superior a 99\% para detectar diferenças com effect size $ \geq $ 0.2, validando estatisticamente as comparações realizadas com o estado da arte apresentadas nos resultados.

\section{Etapas de Desenvolvimento}
\label{sec:etapas-desenvolvimento}

As etapas de desenvolvimento seguem respectivamente:

\begin{alineascomnumero}
	\item Modelagem, impressão e montagem do chassi do carrinho;
	\item Testes de desempenho e comunicação entre o Raspberry Pi e o Cliente (PC);
	\item Integração gradual dos sensores e atuadores do carrinho com o Raspberry Pi;
	\item Testes de comunicação do carrinho completo entre o PC\@;
	\item Modelagem, impressão e montagem do cockpit;
	\item Teste de atuadores e sensores de comando da direção e pedais para o PC via serial;
	\item Integração gradual do cockpit com o PC via serial;
	\item Teste completo entre o carrinho e o cockpit.
\end{alineascomnumero}

\section{Armazenamento de Logs e Validação}
\label{sec:logs-validacao}

Serão armazenados logs no PC (cliente) para validação das telemetrias entre corridas e assim analisar como na Fórmula 1 atual, usando bibliotecas do Python próprias para isso. Esses logs também serão úteis para analisar os sensores e assim melhorar a adaptabilidade do simulador para situações cada vez mais reais de corridas.

\section{Limitações e Considerações de Alcance}
\label{sec:limitacoes-alcance}

O alcance da rede WiFi é limitado ao range do roteador; porém, o uso de redes mesh torna possível a criação do projeto em escala 1:8 devido ao tamanho de pistas de corridas reais que não passarão de 600 metros de distância. Assim, um local aberto possibilita a criação de simuladores em tempo real, e também o uso de conexão 5G possibilita a melhoria de maior redução de latência.

% TODO: Adicionar figura da arquitetura do sistema
% A \autoref{fig:arquitetura-sistema} apresenta a arquitetura geral do sistema proposto, mostrando a comunicação entre o carrinho, o cliente PC e o cockpit através do protocolo UDP.
% \begin{figure}[h!]
%     \captionsetup{width=16cm}
%     \Caption{\label{fig:arquitetura-sistema} Diagrama da arquitetura do sistema de controle remoto com force feedback}
%     \UFCfig{}{
%         \includegraphics[width=16cm]{figuras/arquitetura-sistema}
%     }{
%         \Fonte{elaborado pelo autor.}
%     }
% \end{figure}

\section{Reprodutibilidade e Transparência Experimental}
\label{sec:reprodutibilidade-transparencia}

A garantia de reprodutibilidade científica constitui um pilar fundamental para a validação e evolução do conhecimento em engenharia de sistemas embarcados. Seguindo as diretrizes estabelecidas por \citeonline{graf2024monitoring} para avaliação de desempenho de sistemas wireless, este trabalho adota protocolos rigorosos de documentação e disponibilização de recursos para permitir a replicação completa dos experimentos realizados.

\subsection{Disponibilização de Código Fonte e Datasets}
\label{subsec:codigo-datasets}

Todo o código fonte desenvolvido para este projeto será disponibilizado publicamente sob licença MIT, incluindo os scripts de controle do Raspberry Pi 4, firmware do ESP32 para leitura de encoders e controle de force feedback, interface gráfica em Python/Tkinter e rotinas de análise estatística dos dados coletados. Conforme demonstrado por \citeonline{bobrovsky2023development}, a transparência no desenvolvimento de sistemas embarcados facilita a reprodução e melhoria contínua das soluções propostas.

Os datasets coletados durante as sessões experimentais, totalizando mais de 90.000 pontos de telemetria e 26.925 frames de vídeo, serão disponibilizados em formato estruturado JSON e CSV, acompanhados de metadados descritivos. Cada arquivo de dataset incluirá timestamps precisos em formato ISO 8601, identificadores únicos de sessão, condições experimentais documentadas e checksums MD5 para verificação de integridade. A estrutura de dados segue o padrão FAIR (Findable, Accessible, Interoperable, Reusable), garantindo máxima reutilização pelos pesquisadores.

\subsection{Protocolo Detalhado de Replicação}
\label{subsec:protocolo-replicacao}

O protocolo de replicação experimental documentado contempla todos os aspectos críticos para reprodução fidedigna dos resultados obtidos. As especificações de hardware incluem números de modelo exatos, versões de firmware e configurações específicas de cada componente utilizado no sistema. Para o Raspberry Pi 4, documenta-se a versão do Raspberry Pi OS (Bullseye 64-bit), kernel utilizado (5.15.84-v8+) e configurações específicas do arquivo config.txt para otimização da câmera OV5647.

As configurações de rede wireless seguem padrões reproduzíveis, especificando canal WiFi (2.4GHz canal 6), potência de transmissão (20dBm), tipo de roteador utilizado (TP-Link Archer C6) e posicionamento físico dos equipamentos. As condições ambientais durante os experimentos são registradas detalhadamente, incluindo temperatura ambiente (22±2°C), umidade relativa (45±5\%), interferências eletromagnéticas medidas e layout físico do ambiente de teste.

\subsection{Documentação de Configurações Ambientais}
\label{subsec:configuracoes-ambientais}

As configurações ambientais experimentais são registradas sistematicamente para garantir reprodutibilidade das condições de teste. O ambiente de rede é caracterizado através de medições de potência de sinal WiFi utilizando ferramentas como iwconfig e wavemon, documentando valores de RSSI (Received Signal Strength Indicator) em múltiplos pontos do ambiente experimental.

As características do ambiente físico incluem dimensões precisas do local de teste (5m × 8m), materiais de construção das paredes (alvenaria com reboco), presença de obstáculos metálicos e fontes potenciais de interferência eletromagnética. O posicionamento relativo entre carrinho e estação de controle é documentado com coordenadas precisas, utilizando sistema de referência baseado em marcos físicos permanentes.

As condições de iluminação para os testes de câmera são padronizadas utilizando iluminação artificial controlada (lâmpadas LED 6500K, 1000 lúmens), minimizando variações devido à iluminação natural. Os padrões de teste visual incluem alvos de calibração com dimensões conhecidas, permitindo validação da qualidade de captura de vídeo independente das condições específicas do ambiente.

O controle de temperatura ambiente utiliza sistema de climatização para manter estabilidade térmica durante as sessões experimentais, evitando drift térmico excessivo nos sensores. Registros contínuos de temperatura e umidade são mantidos através de datalogger dedicado, correlacionando variações ambientais com performance do sistema.
